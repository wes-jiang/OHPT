ChapterâŒ˜PageâŒ˜Text
4âŒ˜0âŒ˜Chapter 4 Paths ingraphs 4.1 Distances Depth-rst searc hreadily identies allthevertices ofagraph that canbereached from a designated starting point. Italso nds explicit paths tothese vertices ,summarized inits searc htree (Figure 4.1). However ,these paths might notbethemost economical ones possi- ble.Inthegure ,vertexCisreachable fromSbytraversing justoneedge,while theDFS tree shows apath oflength 3.This chapter isabout algorithms fornding shortest paths ingraphs . Pathlengths allow ustotalk quantitatively about theextent towhic hdifferent vertices of agraph areseparated from eachother: Thedistance between twonodes isthelength oftheshortest path between them. Togetaconcrete feelforthisnotion, consider aphysical realization ofagraph that hasaball foreachvertex andapiece ofstring foreachedge.Ifyoulifttheballforvertexshigh enough, theother balls that getpulled upalong with itareprecisely thevertices reachable froms. And tondtheir distances froms,youneed only measure how farbelowsthey hang . Figure 4.1(a)Asimple graph and(b)itsdepth-rst searc htree. (a) E A S B D C(b)S A BD E C 115
4âŒ˜1âŒ˜116 Algorithms Figure 4.2Aphysical model ofagraph. BE S D CAS DEC BA InFigure 4.2forexample ,vertexBisatdistance 2fromS,and there aretwoshortest paths toit.WhenSisheld up,thestrings along eachofthese paths become taut. Onthe other hand, edge(D;E)playsnoroleinanyshortest path andtherefore remains slack. 4.2 Breadth-rst search InFigure 4.2,thelifting ofspartitions thegraph into layers:sitself ,thenodes atdistance 1from it,thenodes atdistance 2from it,andsoon.Aconvenient waytocompute distances fromstotheother vertices istoproceed layerbylayer.Once wehavepickedoutthenodes atdistance 0;1;2;:::;d,theones atd+1areeasily determined: they areprecisely theas-yet- unseen nodes that areadjacent tothelayeratdistanced.This suggests aniterative algorithm inwhic htwolayers areactive atanygiven time: some layerd,whic hhasbeen fully identied, andd+1,whic hisbeing discovered byscanning theneighbors oflayerd. Breadth-rst searc h(BFS) directly implements this simple reasoning (Figure 4.3). Ini- tially thequeueQconsists only ofs,theonenode atdistance 0.And foreachsubsequent distanced=1;2;3;:::,there isapoint intime atwhic hQcontains allthenodes atdistance dand nothing else.Asthese nodes areprocessed (ejected offthefront ofthequeue), their as-yet-unseen neighbors areinjected into theendofthequeue . Let'stryoutthisalgorithm onourearlier example (Figure 4.1)toconrm that itdoes the right thing .IfSisthestarting point andthenodes areordered alphabetically ,they getvisited inthesequence shown inFigure 4.4.Thebreadth-rst searc htree,ontheright, contains the edges through whic heachnode isinitially discovered. Unlike theDFS tree wesawearlier ,it hastheproperty that allitspaths fromSaretheshortest possible .Itistherefore ashortest- path tree. Correctness and efciency Wehavedeveloped thebasic intuition behind breadth-rst searc h.Inorder tocheckthat thealgorithm works correctly ,weneed tomake sure that itfaithfully executes thisintuition. What weexpect, precisely ,isthat Foreachd=0;1;2;:::,there isamoment atwhic h(1)allnodes atdistanced
4âŒ˜2âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 117 Figure 4.3Breadth-rst searc h. procedure bfs(G;s) Input: GraphG=(V;E),directed orundirected; vertexs2V Output: Forallvertices ureachable froms,dist(u)isset tothedistance fromstou. forallu2V: dist(u)=1 dist(s)=0 Q=[s](queuecontaining justs) whileQisnotempty: u=eject (Q) foralledges (u;v)2E: ifdist(v)=1: inject (Q;v) dist(v)=dist(u)+1 fromshavetheir distances correctly set;(2)allother nodes havetheir distances setto1;and(3)thequeue contains exactly thenodes atdistanced. This hasbeen phrased with aninductive argument inmind. Wehavealready discussed both thebase case andtheinductive step.Can youllinthedetails? The overall running time ofthis algorithm islinear ,O(jVj+jEj),forexactly thesame reasons asdepth-rst searc h.Eachvertex isputonthequeue exactly once,when itisrst en- countered, sothere are2jVjqueue operations .Therestofthework isdone inthealgorithm' s innermost loop.Over thecourse ofexecution, this loop looks ateachedge once (indirected graphs) ortwice (inundirected graphs), andtherefore takesO(jEj)time. Now that wehaveboth BFS andDFS before us:how dotheir exploration styles compare? Depth-rst searc hmakes deep incursions intoagraph, retreating only when itruns outofnew nodes tovisit. This strategy gives itthewonderful, subtle ,and extremely useful properties wesawintheChapter 3.Butitalsomeans that DFS canenduptaking along andconvoluted route toavertex that isactually very close by,asinFigure 4.1. Breadth-rst searc hmakes sure tovisit vertices inincreasing order oftheir distance from thestarting point. This isa broader ,shallower searc h,rather likethepropagation ofawaveupon water.And itisachieved using almost exactly thesame code asDFSÂ—but with aqueue inplace ofastack. Also notice onestylistic difference from DFS: since weareonly interested indistances froms,wedonotrestart thesearc hinother connected components .Nodes notreachable from saresimply ignored.
4âŒ˜3âŒ˜118 Algorithms Figure 4.4Theresult ofbreadth-rst searc honthegraph ofFigure 4.1. Order Queue contents ofvisitation after processing node [S] S [ACDE] A [CDEB] C [DEB] D [EB] E [B] B []D A BC ES Figure 4.5Edge lengths often matter . FranciscoSan Los AngelesBakersfieldSacramento Reno Las Vegas40929095 271133 445 291 112 275 4.3 Lengths onedges Breadth-rst searc htreats alledges ashaving thesame length. This israrely true inap- plications where shortest paths aretobefound. Forinstance ,suppose youaredriving from San Francisco toLasVegas,andwanttond thequickest route .Figure 4.5shows themajor highw aysyoumight conceivably use.Picking theright combination ofthem isashortest-path problem inwhic hthelength ofeachedge (eachstretc hofhighw ay)isimportant. Forthere- mainder ofthischapter ,wewilldeal with thismore general scenario ,annotating every edge e2Ewith alengthle.Ife=(u;v),wewillsometimes also writel(u;v)orluv. Thesele'sdonothavetocorrespond tophysical lengths .They could denote time (driving time between cities) ormoney (cost oftaking abus), oranyother quantity that wewould like toconserve .Infact, there arecases inwhic hweneed tousenegative lengths ,butwewill briey overlook thisparticular complication.
4âŒ˜4âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 119 Figure 4.6Breaking edges into unit-length pieces . CAB ED C ED B A 122 423 1 4.4 Dijkstra' salgorithm 4.4.1 Anadaptation ofbreadth-rst search Breadth-rst searc hnds shortest paths inanygraph whose edges haveunit length. Can we adapt ittoamore general graphG=(V;E)whose edge lengthslearepositive integer s? Amore convenient graph Here isasimple trickforconverting Ginto something BFS canhandle: breakG'slong edges into unit-length pieces ,byintroducing Â“dummyÂ” nodes .Figure 4.6shows anexample ofthis transformation. Toconstruct thenew graphG0, Forany edgee=(u;v)ofE,replace itbyleedges oflength 1,byaddingle1 dummy nodes betweenuandv. GraphG0contains alltheverticesVthat interest us,and thedistances between them are exactly thesame asinG.Most importantly ,theedges ofG0allhaveunit length. Therefore , wecancompute distances inGbyrunning BFS onG0. Alarm clocks Ifefciency were notanissue ,wecould stop here.ButwhenGhasvery long edges ,theG0 itengenders isthicklypopulated with dummy nodes ,and theBFS spends most ofitstime diligently computing distances tothese nodes that wedon't care about atall. Toseethismore concretely ,consider thegraphsGandG0ofFigure 4.7,andimagine that theBFS,started atnodesofG0,advances byoneunit ofdistance perminute .Fortherst 99minutes ittediously progresses alongSAandSB,anendless desert ofdummy nodes . Isthere some waywecansnooze through these boring phases and haveanalarm wakeus upwhenever something interesting ishappeningÂ—specically ,whenever oneoftherealnodes (from theoriginal graphG)isreached? Wedothisbysetting twoalarms attheoutset, onefornodeA,settogooffattimeT=100, andoneforB,attimeT=200.These areestimated times ofarrival ,based upon theedges currently being traversed. Wedoze offandawakeatT=100tondAhasbeen discovered. At
4âŒ˜5âŒ˜120 Algorithms thispoint, theestimated time ofarrival forBisadjusted toT=150andwechange itsalarm accordingly . More generally ,atanygiven moment thebreadth-rst searc hisadvancing along certain edges ofG,andthere isanalarm forevery endpoint node towardwhic hitismoving ,setto gooffattheestimated time ofarrival atthat node .Some ofthese might beoverestimates be- cause BFS maylater ndshortcuts ,asaresult offuture arrivals elsewhere .Inthepreceding example ,aquickerroute toBwasrevealed upon arrival atA.However ,nothing interesting canpossibl yhappen beforeanalarm goes off.Thesounding ofthenext alarm must therefore signal thearrival ofthewavefront toarealnodeu2VbyBFS.Atthat point, BFS might also start advancing along some new edges outofu,andalarms need tobesetfortheir endpoints . Thefollowing Â“alarm clockalgorithmÂ” faithfully simulates theexecution ofBFS onG0. Setanalarm clockfornodesattime0. Repeat until there arenomore alarms: Saythenext alarm goes offattimeT,fornodeu.Then: Â–Thedistance fromstouisT. Â–ForeachneighborvofuinG: Ifthere isnoalarm yetforv,setonefortimeT+l(u;v). Ifv'salarm issetforlater thanT+l(u;v),then reset ittothisearlier time. Dijkstra' salgorithm. Thealarm clockalgorithm computes distances inanygraph with positive integral edge lengths .Itisalmost ready foruse,except that weneed tosomehow implement thesystem ofalarms .The right data structure forthis jobisapriority queue (usually implemented viaaheap ),whic hmaintains asetofelements (nodes) with associated numeric keyvalues (alarm times) andsupports thefollowing operations: Insert. Add anew element totheset. Decrease-key .Accommodate thedecrease inkeyvalue ofaparticular element.1 1Thename decrease-key isstandard butisalittle misleading: thepriority queue typically does notitself change keyvalues .What thisprocedure really does istonotify thequeue that acertain keyvalue hasbeen decreased. Figure 4.7BFS onG0ismostly uneventful. Thedotted lines show some early Â“wavefronts .Â” G:A BS 200100 50G0: SA B
4âŒ˜6âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 121 Delete-min. Return theelement with thesmallest key,andremove itfrom theset. Make-queue .Build apriority queue outofthegiven elements ,with thegiven key values .(Inmany implementations ,this issignicantly faster than inserting the elements onebyone.) The rst twoletussetalarms ,andthethird tells uswhic halarm isnext togooff.Putting thisalltogether ,wegetDijkstra' salgorithm (Figure 4.8). Inthecode,dist (u)refers tothecurrent alarm clocksetting fornodeu.Avalue of1 means thealarm hasn't sofarbeen set. There isalso aspecial array,prev ,that holds one crucial piece ofinformation foreachnodeu:theidentity ofthenode immediately before it ontheshortest path fromstou.Byfollowing these back-pointers ,wecaneasily reconstruct shortest paths ,andsothisarrayisacompact summary ofallthepaths found. Afullexample ofthealgorithm' soperation, along with thenal shortest-path tree,isshown inFigure 4.9. Insummary ,wecanthink ofDijkstra' salgorithm asjust BFS,except ituses apriority queue instead ofaregular queue ,soastoprioritize nodes inawaythat takes edge lengths into account. This viewpoint gives aconcrete appreciation ofhow and why thealgorithm works ,butthere isamore direct, more abstract derivation that doesn't depend upon BFS at all.Wenow start from scratc hwith thiscomplementary interpretation. Figure 4.8Dijkstra' sshortest-path algorithm. procedure dijkstra (G;l;s) Input: GraphG=(V;E),directed orundirected; positive edgelengthsfle:e2Eg;vertexs2V Output: Forallvertices ureachable froms,dist(u)isset tothedistance fromstou. forallu2V: dist(u)=1 prev(u)=nil dist(s)=0 H=makequeue (V)(usingdist-values askeys) whileHisnotempty: u=deletemin (H) foralledges (u;v)2E: ifdist(v)>dist(u)+l(u;v): dist(v)=dist(u)+l(u;v) prev(v)=u decreasekey (H;v)
4âŒ˜7âŒ˜122 Algorithms Figure 4.9Acomplete runofDijkstra' salgorithm, with nodeAasthestarting point. Also shown aretheassociated dist values andthenal shortest-path tree. B CD EA4 1 32 4 1 3 52A:0D:1 B:4E:1 C:2 B CD EA42 4 1 3 521 3A:0D:6 B:3E:7 C:2 B CD EA4 1 32 4 1 3 52A:0D:5 B:3E:6 C:2 B CD EA4 1 32 1 5234 A:0D:5 B:3E:6 C:2 B CD EA 21 32
4âŒ˜8âŒ˜"S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 123 Figure 4.10 Single-edge extensions ofknown shortest paths .                !""#$%&'( ()* *+ , ,-. ./ 0 01 1suRKnown region v 4.4.2 Analternative derivation Here' saplan forcomputing shortest paths: expand outw ardfrom thestarting points,steadily growing theregion ofthegraph towhic hdistances andshortest paths areknown. This growth should beorderly ,rst incorporating theclosest nodes and then moving ontothose further away.More precisely ,when theÂ“known regionÂ” issome subset ofverticesRthat includess, thenext addition toitshould bethenode outsideRthat isclosest tos.Letuscallthisnodev; thequestion is:how doweidentify it? Toanswer ,consideru,thenode justbeforevintheshortest path fromstov:23 45 67vus Since weareassuming that alledge lengths arepositive ,umust becloser tosthanvis.This means thatuisinRÂ—otherwise itwould contradict v'sstatus astheclosest node tosoutside R.So,theshortest path fromstovissimply aknown shortest path extended byasingle edge. Butthere willtypically bemany single-edge extensions ofthecurrently known shortest paths (Figure 4.10); whic hofthese identiesv?Theanswer is,theshortest ofthese extended paths .Because ,ifaneven shorter single-edge-extended path existed, this would once more contradict v'sstatus asthenode outsideRclosest tos.So,it'seasy tondv:itisthenode outsideRforwhic hthesmallest value ofdistance (s;u)+l(u;v)isattained, asuranges over R.Inother words ,tryallsingle-edge extensions ofthecurrentl yknown shortest paths ,nd the shortest suchextended path, andproclaim itsendpoint tobethenext node ofR. Wenow haveanalgorithm forgrowingRbylooking atextensions ofthecurrent setof shortest paths .Some extra efciency comes from noticing that onany given iteration, the only new extensions arethose involving thenode most recently added toregionR.Allother extensions will havebeen assessed previously and donotneed toberecomputed. Inthe following pseudocode ,dist(v)isthelength ofthecurrently shortest single-edge-extended path leading tov;itis1fornodes notadjacent toR."
4âŒ˜9âŒ˜124 Algorithms Initialize dist(s)to0,otherdist()valuesto1 R=fg(the``known region'') whileR6=V: Pickthenodev62Rwithsmallest dist() AddvtoR foralledges (v;z)2E: ifdist(z)>dist(v)+l(v;z): dist(z)=dist(v)+l(v;z) Incorporating priority queue operations gives usbackDijkstra' salgorithm (Figure 4.8). Tojustify thisalgorithm formally ,wewould useaproof byinduction, aswith breadth-rst searc h.Here' sanappropriate inductive hypothesis . Attheendofeachiteration ofthewhile loop,thefollowing conditions hold: (1) there isavaluedsuchthat allnodes inRareatdistancedfromsand all nodes outsideRareatdistancedfroms,and (2)forevery nodeu,thevalue dist(u)isthelength oftheshortest path fromstouwhose intermediate nodes areconstrained tobeinR(ifnosuchpath exists ,thevalue is1). The base case isstraightforw ard(withd=0),and thedetails oftheinductive step canbe lled infrom thepreceding discussion. 4.4.3 Running time Atthelevel ofabstraction ofFigure 4.8, Dijkstra' salgorithm isstructurally identical to breadth-rst searc h.However ,itisslower because thepriority queue primitives arecom- putationally more demanding than theconstant-time eject 'sandinject 'sofBFS.Since makequeue takes atmost aslong asjVjinsert operations ,wegetatotal ofjVjdeletemin andjVj+jEjinsert /decreasek eyoperations .The time needed forthese varies byimple- mentation; forinstance ,abinary heap gives anoverall running time ofO((jVj+jEj)logjVj).
4âŒ˜10âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 125 Which heap isbest? The running time ofDijkstra' salgorithm depends heavilyonthepriority queue implemen- tation used. Here arethetypical choices . Implementation deletemininsert/ decreasekeyjVjdeletemin + (jVj+jEj)insert Arra y O(jVj) O(1) O(jVj2) Binary heap O(logjVj)O(logjVj) O((jVj+jEj)logjVj) d-ary heap O(dlogjVj logd)O(logjVj logd) O((jVjd+jEj)logjVj logd) Fibonacci heapO(logjVj)O(1)(amortized) O(jVjlogjVj+jEj) Soforinstance ,even anaive arrayimplementation gives arespectable time complexity ofO(jVj2),whereas with abinary heap wegetO((jVj+jEj)logjVj).Whic hispreferable? This depends onwhether thegraph issparse(has fewedges) ordense (has lotsofthem). Forallgraphs ,jEjislessthanjVj2.Ifitis (jVj2),then clearly thearrayimplementation is thefaster .Ontheother hand, thebinary heap becomes preferable assoon asjEjdips below jVj2=logjVj. Thed-ary heap isageneralization ofthebinary heap (whic hcorresponds tod=2)and leads toarunning time that isafunction ofd.The optimal choice isdjEj=jVj;inother words ,tooptimize wemust setthedegree oftheheap tobeequal totheaverage degree ofthe graph. This works well forboth sparse anddense graphs .Forvery sparse graphs ,inwhic h jEj=O(jVj),therunning time isO(jVjlogjVj),asgood aswith abinary heap .Fordense graphs ,jEj= (jVj2)andtherunning time isO(jVj2),asgood aswith alinked list. Finally , forgraphs with intermediate densityjEj=jVj1+,therunning time isO(jEj),linear! Thelastlineinthetable gives running times using asophisticated data structure called aFibonacci heap .Although itsefciency isimpressive ,this data structure requires con- siderably more work toimplement than theothers ,andthis tends todampen itsappeal in practice .Wewillsaylittle about itexcept tomention acurious feature ofitstime bounds . Itsinsert operations take varying amounts oftime butareguaranteed toaverageO(1) over thecourse ofthealgorithm. Insuchsituations (one ofwhic hweshall encounter in Chapter 5)wesaythat theamortized costofheapinsert 'sisO(1).
4âŒ˜11âŒ˜126 Algorithms 4.5 Priority queue implementations 4.5.1 Array The simplest implementation ofapriority queue isasanunordered arrayofkeyvalues for allpotential elements (the vertices ofthegraph, inthecase ofDijkstra' salgorithm). Initially , these values aresetto1. Aninsert ordecreasekey isfast, because itjustinvolves adjusting akeyvalue ,anO(1) operation. Todeletemin ,ontheother hand, requires alinear -time scan ofthelist. 4.5.2 Binary heap Here elements arestored inacomplete binary tree,namely ,abinary tree inwhic heachlevel islled infrom lefttoright, and must befullbefore thenext level isstarted. Inaddition, aspecial ordering constraint isenforced: thekeyvalue ofanynode ofthetreeislessthan or equal tothat ofitschildren .Inparticular ,therefore ,theroot alwayscontains thesmallest element. SeeFigure 4.11(a) foranexample . Toinsert ,place thenew element atthebottom ofthetree(intherst available position), and letitÂ“bubble up.Â”That is,ifitissmaller than itsparent, swapthetwo and repeat (Figure 4.11(b)Â–(d)). The number ofswapsisatmost theheight ofthetree,whic hisblog2nc when there arenelements .Adecreasekey issimilar ,except that theelement isalready in thetree,soweletitbubble upfrom itscurrent position. Todeletemin ,return theroot value .Tothen remove this element from theheap ,take thelastnode inthetree (intherightmost position inthebottom row) andplace itattheroot. LetitÂ“sift downÂ”: ifitisbigger than either child, swapitwith thesmaller child andrepeat (Figure 4.11(e)Â–(g)). Again thistakesO(logn)time. The regularity ofacomplete binary tree makes iteasy torepresent using anarray.The tree nodes haveanatural ordering: rowbyrow,starting attheroot andmoving lefttoright within eachrow.Ifthere arennodes ,this ordering species their positions 1;2;:::;nwithin thearray.Moving upanddown thetree iseasily simulated onthearray,using thefactthat node numberjhasparentbj=2candchildren 2jand2j+1(Exercise 4.16). 4.5.3 d-ary heap Ad-ary heap isidentical toabinary heap ,except that nodes havedchildren instead ofjust two.This reduces theheight ofatreewithnelements to(logdn)=((logn)=(logd)).Inserts aretherefore speeded upbyafactor of(logd).Deletemin operations ,however ,take alittle longer ,namelyO(dlogdn)(doyouseewhy?). Thearrayrepresentation ofabinary heap iseasily extended tothed-ary case.This time, node numberjhasparentd(j1)=deandchildrenf(j1)d+2;:::;minfn;(j1)d+d+1gg (Exercise 4.16).
4âŒ˜12âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 127 Figure 4.11 (a)Abinary heap with10elements .Only thekeyvalues areshown. (b)Â–(d) The intermediate Â“bubble-upÂ” steps ininserting anelement with key7.(e)Â–(g) The Â“sift-downÂ” steps inadelete-min operation. (a) 3 5 10 12 11 6 8 15 20 13(b) 3 5 10 12 11 6 8 15 20 13 7 (c) 3 5 10 11 6 8 15 20 13 127(d) 3 5 11 6 8 15 20 13 127 10 (e) 5 11 6 8 15 20 13 127 10(f) 5 11 6 8 15 20 137 1012 (g) 11 8 15 20 137 10 65 12(h) 11 8 15 20 137 105 6 12
4âŒ˜13âŒ˜128 Algorithms Figure 4.12 Dijkstra' salgorithm willnotwork ifthere arenegative edges . SA Bâˆ’23 4 4.6 Shortest paths inthepresence ofnegative edges 4.6.1 Negative edges Dijkstra' salgorithm works inpart because theshortest path from thestarting pointstoany nodevmust pass exclusively through nodes that arecloser thanv.This nolonger holds when edge lengths canbenegative .InFigure 4.12, theshortest path fromStoApasses throughB, anode that isfurther away! What needs tobechanged inorder toaccommodate thisnew complication? Toanswer this, let'stake aparticular high-level view ofDijkstra' salgorithm. Acrucial invariant isthat the dist values itmaintains arealwayseither overestimates orexactly correct. They start offat 1,andtheonly waythey ever change isbyupdating along anedge: procedure update((u;v)2E) dist(v)=minfdist(v);dist(u)+l(u;v)g This update operation issimply anexpression ofthefactthat thedistance tovcannot possibly bemore than thedistance tou,plusl(u;v).Ithasthefollowing properties . 1.Itgives thecorrect distance tovintheparticular case whereuisthesecond-last node intheshortest path tov,anddist(u)iscorrectly set. 2.Itwillnever makedist(v)toosmall, andinthissense itissafe.Forinstance ,aslew of extraneous update 'scan't hurt. This operation isextremely useful: itisharmless ,and ifused carefully ,will correctly set distances .Infact, Dijkstra' salgorithm canbethought ofsimply asasequence ofupdate 's. Weknow this particular sequence doesn't work with negative edges ,butisthere some other sequence that does? Togetasense oftheproperties this sequence must possess ,let'spicka nodetandlook attheshortest path toitfroms.      t s u1u2u3 uk This path canhaveatmostjVj1edges (doyouseewhy?). Ifthesequence ofupdates per- formed includes (s;u1);(u1;u2);(u2;u3);:::;(uk;t),inthat order (though notnecessarily con- secutively), then bytherst property thedistance totwillbecorrectly computed. Itdoesn't
4âŒ˜14âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 129 Figure 4.13 TheBellman-F ordalgorithm forsingle-source shortest paths ingeneral graphs . procedure shortest-paths (G;l;s) Input: Directed graphG=(V;E); edgelengthsfle:e2Egwithnonegative cycles; vertexs2V Output: Forallvertices ureachable froms,dist(u)isset tothedistance fromstou. forallu2V: dist(u)=1 prev(u)=nil dist(s)=0 repeatjVj1times: foralle2E: update(e) matter what other updates occur onthese edges ,orwhat happens intherest ofthegraph, because updates aresafe. Butstill, ifwedon't know alltheshortest paths beforehand, how canwebesure toupdate theright edges intheright order? Here isaneasy solution: simply update alltheedges , jVj1times! The resultingO(jVjjEj)procedure iscalled theBellman-F ordalgorithm and isshown inFigure 4.13, with anexample runinFigure 4.14. Anote about implementation: formany graphs ,themaximum number ofedges inany shortest path issubstantially lessthanjVj1,with theresult that fewer rounds ofupdates areneeded. Therefore ,itmakes sense toaddanextra checktotheshortest-path algorithm, tomake itterminate immediately after anyround inwhic hnoupdate occurred. 4.6.2 Negative cycles Ifthelength ofedge(E;B)inFigure 4.14 were changed to4,thegraph would haveanegative cycleA!E!B!A.Insuchsituations ,itdoesn't make sense toeven askabout shortest paths .There isapath oflength 2fromAtoE.Butgoing round thecycle,there' salso apath oflength 1,andgoing round multiple times ,wendpaths oflengths 0;1;2,andsoon. The shortest-path problem isill-posed ingraphs with negative cycles.Asmight beex- pected, ouralgorithm from Section 4.6.1 works only intheabsence ofsuchcycles.Butwhere didthis assumption appear inthederivation ofthealgorithm? Well,itslipped inwhen we asserted theexistence ofashortest path fromstot. Fortunately ,itiseasy toautomatically detect negative cyclesandissue awarning .Sucha cyclewould allow ustoendlessly apply rounds ofupdate operations ,reducingdist estimates every time.Soinstead ofstopping afterjVj1iterations ,perform oneextra round. There is anegative cycleifandonly ifsomedist value isreduced during thisnal round.
4âŒ˜15âŒ˜130 Algorithms Figure 4.14 TheBellman-F ordalgorithm illustrated onasample graph. EBA G F DS C 311 2210 1 14 18 Iteration Node 0 1 2 3 4 5 67 S 00000000 A1101055555 B111106555 C111111766 D1111114109 E111287777 F11999999 G18888888 4.7 Shortest paths indags There aretwosubclasses ofgraphs that automatically exclude thepossibility ofnegative cy- cles: graphs without negative edges ,and graphs without cycles.Wealready know how to efciently handle theformer .Wewillnow seehow thesingle-source shortest-path problem canbesolved injustlinear time ondirected acyclicgraphs . Asbefore ,weneed toperform asequence ofupdates that includes every shortest path as asubsequence .Thekeysource ofefciency isthat Inanypath ofadag,thevertices appear inincreasing linearized order . Therefore ,itisenough tolinearize (that is,topologically sort) thedagbydepth-rst searc h, andthen visit thevertices insorted order ,updating theedges outofeach.The algorithm is given inFigure 4.15. Notice that ourscheme doesn't require edges tobepositive .Inparticular ,wecannd longest paths inadagbythesame algorithm: justnegate alledge lengths .
4âŒ˜16âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 131 Figure 4.15 Asingle-source shortest-path algorithm fordirected acyclicgraphs . procedure dag-shortest-pat hs(G;l;s) Input: DagG=(V;E); edgelengthsfle:e2Eg;vertexs2V Output: Forallvertices ureachable froms,dist(u)isset tothedistance fromstou. forallu2V: dist(u)=1 prev(u)=nil dist(s)=0 Linearize G foreachu2V,inlinearized order: foralledges (u;v)2E: update(u;v)
4âŒ˜17âŒ˜132 Algorithms Exercises 4.1. Suppose Dijkstra' salgorithm isrunonthefollowing graph, starting atnodeA. A B C D E F G H1 2 412 68 56 4 1 11 (a)Drawatable showing theintermediate distance values ofallthenodes ateachiteration of thealgorithm. (b)Show thenal shortest-path tree. 4.2. Justliketheprevious problem, butthistime with theBellman-F ordalgorithm. B G H IC D F ESA 7 1 âˆ’4 65 3âˆ’232âˆ’2 64 âˆ’2 1 âˆ’11 4.3. Squares .Design andanalyze analgorithm that takes asinput anundirected graphG=(V;E) anddetermines whetherGcontains asimple cycle(that is,acyclewhic hdoesn't intersect itself) oflength four.Itsrunning time should beatmostO(jVj3). Youmayassume that theinput graph isrepresented either asanadjacency matrix orwith adjacency lists,whic hever makes your algorithm simpler . 4.4. Here' saproposal forhow tondthelength oftheshortest cycleinanundirected graph with unit edge lengths . When abackedge ,say(v;w),isencountered during adepth-rst searc h,itforms a cyclewith thetree edges fromwtov.Thelength ofthecycleislevel[v]level[w]+1, where thelevel ofavertex isitsdistance intheDFS tree from theroot vertex. This suggests thefollowing algorithm: Doadepth-rst searc h,keeping trackofthelevel ofeachvertex. Eachtime abackedge isencountered, compute thecyclelength andsaveitifitis smaller than theshortest onepreviously seen. Show that this strategy does notalwayswork byproviding acounterexample aswell asabrief (one ortwosentence) explanation.
4âŒ˜18âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 133 4.5. Often there aremultiple shortest paths between twonodes ofagraph. Give alinear -time algo- rithm forthefollowing task. Input: Undirected graphG=(V;E)with unit edge lengths; nodesu;v2V. Output: Thenumber ofdistinct shortest paths fromutov. 4.6. Prove that forthearrayprev computed byDijkstra' salgorithm, theedgesfu;prev[u]g(forall u2V)form atree. 4.7. Youaregiven adirected graphG=(V;E)with (possibly negative) weighted edges ,along with a specic nodes2VandatreeT=(V;E0);E0E.Give analgorithm that checkswhetherTisa shortest-path tree forGwith starting points.Youralgorithm should runinlinear time. 4.8. Professor F.Lake suggests thefollowing algorithm fornding theshortest path from nodesto nodetinadirected graph with some negative edges: addalarge constant toeachedge weight so that alltheweights become positive ,then runDijkstra' salgorithm starting atnodes,andreturn theshortest path found tonodet. Isthisavalid method? Either prove that itworks correctly ,orgive acounterexample . 4.9. Consider adirected graph inwhic htheonly negative edges arethose that leaves;allother edges arepositive .Can Dijkstra' salgorithm, started ats,failonsuchagraph? Prove your answer . 4.10. Youaregiven adirected graph with (possibly negative) weighted edges ,inwhic htheshortest path between anytwovertices isguaranteed tohaveatmostkedges .Give analgorithm that nds theshortest path between twoverticesuandvinO(kjEj)time. 4.11. Give analgorithm that takes asinput adirected graph with positive edge lengths ,andreturns thelength oftheshortest cycleinthegraph (ifthegraph isacyclic,itshould sayso). Your algorithm should take time atmostO(jVj3). 4.12. Give anO(jVj2)algorithm forthefollowing task. Input: Anundirected graphG=(V;E);edge lengthsle>0;anedgee2E. Output: Thelength oftheshortest cyclecontaining edgee. 4.13. Youaregiven asetofcities ,along with thepattern ofhighw aysbetween them, intheform ofan undirected graphG=(V;E).Eachstretc hofhighw aye2Econnects twoofthecities ,andyou know itslength inmiles ,le.Youwanttogetfrom citystocityt.There' soneproblem: your car canonly hold enough gastocoverLmiles .There aregasstations ineachcity,butnotbetween cities .Therefore ,youcanonly take aroute ifevery oneofitsedges haslengthleL. (a)Given thelimitation onyour car'sfueltank capacity ,show how todetermine inlinear time whether there isafeasible route fromstot. (b)Youarenow planning tobuy anew car,and youwanttoknow theminimum fuel tank capacity that isneeded totravelfromstot.Give anO((jVj+jEj)logjVj)algorithm to determine this. 4.14. Youaregiven astrongly connected directed graphG=(V;E)with positive edge weights along with aparticular nodev02V.Give anefcient algorithm fornding shortest paths between all pairsofnodes ,with theonerestriction that these paths must allpass throughv0. 4.15. Shortest paths arenotalwaysunique: sometimes there aretwoormore different paths with the minimum possible length. Show how tosolve thefollowing problem inO((jVj+jEj)logjVj)time.
4âŒ˜19âŒ˜134 Algorithms Input: Anundirected graphG=(V;E);edge lengthsle>0;starting vertexs2V. Output: ABoolean arrayusp[]:foreachnodeu,theentryusp[u]should betrue if andonly ifthere isaunique shortest path fromstou.(Note:usp[s]=true .)
4âŒ˜20âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 135 Figure 4.16 Operations onabinary heap . procedure insert(h;x) bubbleup( h;x;jhj+1) procedure decreasekey (h;x) bubbleup( h;x;h1(x)) function deletemin (h) ifjhj=0: returnnull else: x=h(1) siftdown( h;h(jhj);1) returnx function makeheap (S) h=emptyarrayofsizejSj forx2S: h(jhj+1)=x fori=jSjdownto 1: siftdown( h;h(i);i) returnh procedure bubbleup (h;x;i) (placeelementxinposition iofh,andletitbubbleup) p=di=2e whilei6=1andkey(h(p))>key(x): h(i)=h(p);i=p;p=di=2e h(i)=x procedure siftdown (h;x;i) (placeelementxinposition iofh,andletitsiftdown) c=minchild (h;i) whilec6=0andkey(h(c))<key(x): h(i)=h(c);i=c;c=minchild (h;i) h(i)=x function minchild (h;i) (return theindexofthesmallest childofh(i)) if2i>jhj: return0(nochildren) else: return argminfkey(h(j)):2ijminfjhj;2i+1gg
4âŒ˜21âŒ˜136 Algorithms 4.16. Section 4.5.2 describes awayofstoring acomplete binary tree ofnnodes inanarrayindexed by 1;2;:::;n. (a)Consider thenode atpositionjofthearray.Show that itsparent isatpositionbj=2cand itschildren areat2jand2j+1(ifthese numbers aren). (b)What thecorresponding indices when acompleted-ary tree isstored inanarray? Figure 4.16 shows pseudocode forabinary heap ,modeled onanexposition byR.E. Tarjan.2The heap isstored asanarrayh,whic hisassumed tosupport twoconstant-time operations: jhj,whic hreturns thenumber ofelements currently inthearray; h1,whic hreturns theposition ofanelement within thearray. Thelatter canalwaysbeachieved bymaintaining thevalues ofh1asanauxiliary array. (c)Show that themakeheap procedure takesO(n)time when called onasetofnelements . What istheworst-case input? (Hint: Start byshowing that therunning time isatmostPn i=1log(n=i).) (a)What needs tobechanged toadapt thispseudocode tod-ary heaps? 4.17. Suppose wewanttorunDijkstra' salgorithm onagraph whose edge weights areintegers inthe range 0;1;:::;W,whereWisarelatively small number . (a)Show how Dijkstra' salgorithm canbemade torunintimeO(WjVj+jEj). (b)Show analternative implementation that takes time justO((jVj+jEj)logW). 4.18. Incases where there areseveral different shortest paths between twonodes (and edges have varying lengths), themost convenient ofthese paths isoften theonewith fewest edges .For instance ,ifnodes represent cities andedge lengths represent costs ofying between cities ,there might bemany waystogetfrom citystocitytwhic hallhavethesame cost. Themost convenient ofthese alternatives istheonewhic hinvolves thefewest stopovers .Accordingly ,foraspecic starting nodes,dene best[u]=minimum number ofedges inashortest path fromstou: Intheexample below ,thebest values fornodesS;A;B;C;D;E;Fare0;1;1;1;2;2;3,respectively . SA BCD EF2 24 32 2 11 11 Give anefcient algorithm forthefollowing problem. Input: GraphG=(V;E);positive edge lengthsle;starting nodes2V. Output: Thevalues ofbest[u]should besetforallnodesu2V. 2See: R.E.Tarjan, Data Structures andNetwor kAlgorithms ,Society forIndustrial andApplied Mathematics , 1983.
4âŒ˜22âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 137 4.19. Generalized shortest-paths problem. InInternet routing ,there aredelaysonlines butalso,more signicantly ,delaysatrouters .This motivates ageneralized shortest-paths problem. Suppose that inaddition tohaving edge lengthsfle:e2Eg,agraph also hasvertex costs fcv:v2Vg.Now dene thecost ofapath tobethesum ofitsedge lengths ,plus thecosts of allvertices onthepath (including theendpoints). Give anefcient algorithm forthefollowing problem. Input: Adirected graphG=(V;E);positive edge lengthsleandpositive vertex costs cv;astarting vertexs2V. Output: Anarraycost[]suchthat forevery vertexu,cost[u]istheleast cost ofany path fromstou(i.e.,thecostofthecheapest path), under thedenition above . Notice thatcost[s]=cs. 4.20. There isanetwork ofroadsG=(V;E)connecting asetofcitiesV.Eachroad inEhasan associated lengthle.There isaproposal toaddonenew road tothisnetwork, andthere isalist E0ofpairs ofcities between whic hthenew road canbebuilt. Eachsuchpotential roade02E0has anassociated length. Asadesigner forthepublic works department youareasked todetermine theroade02E0whose addition totheexisting networkGwould result inthemaximum decrease inthedriving distance between twoxed citiessandtinthenetwork. Give anefcient algorithm forsolving thisproblem. 4.21. Shortest path algorithms canbeapplied incurrency trading .Letc1;c2;:::;cnbevarious cur- rencies; forinstance ,c1might bedollars ,c2pounds ,andc3lire.Foranytwocurrencies ciand cj,there isanexchange rateri;j;this means that youcanpurchaseri;junits ofcurrencycjin exchange foroneunit ofci.These exchange rates satisfy thecondition thatri;jrj;i<1,sothat if youstart with aunit ofcurrencyci,change itintocurrencycjandthen convert backtocurrency ci,youendupwith lessthan oneunit ofcurrencyci(thedifference isthecostofthetransaction). (a)Give anefcient algorithm forthefollowing problem: Given asetofexchange ratesri;j, andtwocurrencies sandt,ndthemost advantageous sequence ofcurrency exchanges for converting currencysintocurrencyt.Towardthisgoal, youshould represent thecurrencies andrates byagraph whose edge lengths arerealnumbers . The exchange rates areupdated frequently ,reecting thedemand and supply ofthevarious currencies .Occasionally theexchange rates satisfy thefollowing property: there isasequence of currencies ci1;ci2;:::;ciksuchthatri1;i2ri2;i3rik1;ikrik;i1>1.This means that bystarting with aunit ofcurrencyci1andthen successively converting ittocurrencies ci2;ci3;:::;cik,and nally backtoci1,youwould endupwith more than oneunit ofcurrencyci1.Suchanomalies lastonly afraction ofaminute onthecurrency exchange ,butthey provide anopportunity for risk-free prots . (b)Give anefcient algorithm fordetecting thepresence ofsuchananomaly .Use thegraph representation youfound above . 4.22. Thetramp steamer problem. Youaretheowner ofasteamship that canplybetween agroup ofport citiesV.Youmake money ateachport: avisit tocityiearns youaprot ofpidollars . Meanwhile ,thetransportation costfrom portitoportjiscij>0.Youwanttondacyclicroute inwhic htheratio ofprot tocostismaximized.
4âŒ˜23âŒ˜138 Algorithms Tothis end, consider adirected graphG=(V;E)whose nodes areports ,andwhic hhasedges between eachpair ofports .ForanycycleCinthisgraph, theprot-to-cost ratio is r(C)=P (i;j)2CpjP (i;j)2Ccij: Letrbethemaximum ratio achievable byasimple cycle.One waytodetermine risbybinary searc h:byrst guessing some ratior,andthen testing whether itistoolarge ortoosmall. Consider anypositiver>0.Give eachedge(i;j)aweight ofwij=rcijpj. (a)Show that ifthere isacycleofnegative weight, thenr<r. (b)Show that ifallcyclesinthegraph havestrictly positive weight, thenr>r. (c)Give anefcient algorithm that takes asinput adesired accuracy>0andreturns asimple cycleCforwhic hr(C)r.Justify thecorrectness ofyour algorithm andanalyze its running time interms ofjVj,,andR=max(i;j)2E(pj=cij).
