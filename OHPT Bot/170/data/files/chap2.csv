ChapterâŒ˜PageâŒ˜Text
2âŒ˜0âŒ˜Chapter 2 Divide-and-conquer algorithms Thedivide-and-conquer strategy solves aproblem by: 1.Breaking itinto subproblems that arethemselves smaller instances ofthesame type of problem 2.Recursively solving these subproblems 3.Appropriately combining their answers The real work isdone piecemeal, inthree different places: inthepartitioning ofproblems into subproblems; atthevery tailendoftherecursion, when thesubproblems aresosmall that they aresolved outright; andinthegluing together ofpartial answers .These areheld together andcoordinated bythealgorithm' score recursive structure . Asanintroductory example ,we'll seehow thistechnique yields anew algorithm formulti- plying numbers ,onethat ismuchmore efcient than themethod wealllearned inelementary school! 2.1 Multiplication Themathematician Carl Friedric hGauss (1777Â–1855) once noticed that although theproduct oftwocomplex numbers (a+bi)(c+di)=acbd+(bc+ad)i seems toinvolve fourreal-number multiplications ,itcaninfactbedone with just three :ac, bd,and(a+b)(c+d),since bc+ad=(a+b)(c+d)acbd: Inourbig-Owayofthinking ,reducing thenumber ofmultiplications from four tothree seems wasted ingenuity .Butthismodest improvement becomes very signicant when applied recur - sively. 55
2âŒ˜1âŒ˜56 Algorithms Let'smove awayfrom complex numbers and seehow this helps with regular multiplica- tion. Supposexandyaretwon-bitintegers ,andassume forconvenience thatnisapower of 2(the more general case ishardly anydifferent). Asarst step towardmultiplying xandy, split eachofthem into their leftandright halves ,whic haren=2bitslong: x=xLxR=2n=2xL+xR y=yLyR=2n=2yL+yR. Forinstance ,ifx=10110110 2(the subscript 2means Â“binaryÂ”) thenxL=1011 2,xR=0110 2, andx=1011 224+0110 2.Theproduct ofxandycanthen berewritten as xy=(2n=2xL+xR)(2n=2yL+yR)=2nxLyL+2n=2(xLyR+xRyL)+xRyR: Wewillcomputexyviatheexpression ontheright. Theadditions take linear time,asdothe multiplications bypowers of2(whic haremerely left-shifts). The signicant operations are thefourn=2-bitmultiplications ,xLyL;xLyR;xRyL;xRyR;these wecanhandle byfour recursive calls.Thus ourmethod formultiplying n-bitnumbers starts bymaking recursive calls to multiply these four pairs ofn=2-bitnumbers (four subproblems ofhalf thesize), and then evaluates thepreceding expression inO(n)time.WritingT(n)fortheoverall running time onn-bitinputs ,wegettherecurrence relation T(n)=4T(n=2)+O(n): Wewillsoon seegeneral strategies forsolving suchequations .Inthemeantime ,thisparticu- laroneworks outtoO(n2),thesame running time asthetraditional grade-sc hool multiplica- tion technique .Sowehavearadically new algorithm, butwehaven't yetmade anyprogress inefciency .How canourmethod besped up? This iswhere Gauss' strickcomes tomind. Although theexpression forxyseems tode- mand fourn=2-bitmultiplications ,asbefore justthree willdo:xLyL;xRyR,and(xL+xR)(yL+yR), sincexLyR+xRyL=(xL+xR)(yL+yR)xLyLxRyR.Theresulting algorithm, shown inFigure 2.1, hasanimproved running time of1 T(n)=3T(n=2)+O(n): Thepoint isthat now theconstant factor improvement, from 4to3,occurs atevery level ofthe recur sion,andthiscompounding effect leads toadramatically lower time bound ofO(n1:59). This running time canbederived bylooking atthealgorithm' spattern ofrecursive calls, whic hform atreestructure ,asinFigure 2.2.Let'strytounderstand theshape ofthistree.At eachsuccessive level ofrecursion thesubproblems gethalved insize.Atthe(log2n)thlevel, 1Actually ,therecurrence should read T(n)3T(n=2+1)+O(n) since thenumbers (xL+xR)and(yL+yR)could ben=2+1bitslong.Theonewe're using issimpler todeal with andcanbeseen toimply exactly thesame big-Orunning time.
2âŒ˜2âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 57 Figure 2.1Adivide-and-conquer algorithm forinteger multiplication. function multiply (x;y) Input: Positive integers xandy,inbinary Output: Theirproduct n=max(size ofx,sizeofy) ifn=1:returnxy xL,xR=leftmostdn=2e,rightmostbn=2cbitsofx yL,yR=leftmostdn=2e,rightmostbn=2cbitsofy P1=multiply (xL;yL) P2=multiply (xR;yR) P3=multiply (xL+xR;yL+yR) returnP12n+(P3P1P2)2n=2+P2 thesubproblems getdown tosize1,and sotherecursion ends .Therefore ,theheight ofthe tree islog2n.The branc hing factor is3Â—eac hproblem recursively produces three smaller onesÂ—with theresult that atdepthkinthetree there are3ksubproblems ,eachofsizen=2k. Foreachsubproblem, alinear amount ofwork isdone inidentifying further subproblems andcombining their answers .Therefore thetotal time spent atdepthkinthetree is 3kOn 2k =3 2k O(n): Atthevery toplevel, whenk=0,this works outtoO(n).Atthebottom, whenk=log2n, itisO(3log2n),whic hcanberewritten asO(nlog23)(doyouseewhy?). Between these two endpoints ,thework done increases geometricall yfromO(n)toO(nlog23),byafactor of3=2per level. Thesum ofanyincreasing geometric series is,within aconstant factor ,simply thelast term oftheseries: suchistherapidity oftheincrease (Exercise 0.2). Therefore theoverall running time isO(nlog23),whic hisaboutO(n1:59). Intheabsence ofGauss' strick,therecursion tree would havethesame height, butthe branc hing factor would be4.There would be4log2n=n2leaves,and therefore therunning time would beatleast thismuch.Individe-and-conquer algorithms ,thenumber ofsubprob- lems translates intothebranc hing factor oftherecursion tree; small changes inthiscoefcient canhaveabigimpact onrunning time. Apractical note: itgenerally does notmake sense torecurse allthewaydown to1bit.For most processors ,16-or32-bit multiplication isasingle operation, sobythetime thenumbers getinto thisrange they should behanded over tothebuilt-in procedure . Finally ,theeternal question: Can wedobetter? Itturns outthat even faster algorithms formultiplying numbers exist, based onanother important divide-and-conquer algorithm: the fastFourier transform, tobeexplained inSection 2.6.
2âŒ˜3âŒ˜58 Algorithms Figure 2.2Divide-and-conquer integer multiplication. (a)Eachproblem isdivided into three subproblems .(b)Thelevels ofrecursion. (a) 1011001001100011 10110110 00100011 11011001 (b) 2 1 112 1 112 1 112 1 11Sizen Sizen=2 ......logn levelsSizen=4 2.2 Recurrence relations Divide-and-conquer algorithms often follow ageneric pattern: they tackleaproblem ofsize nbyrecursively solving ,say,asubproblems ofsizen=bandthen combining these answers in O(nd)time,forsomea;b;d>0(inthemultiplication algorithm, a=3,b=2,andd=1).Their running time cantherefore becaptured bytheequationT(n)=aT(dn=be)+O(nd).Wenext derive aclosed-form solution tothis general recurrence sothat wenolonger havetosolve it explicitly ineachnew instance . Master theorem2IfT(n)=aT(dn=be)+O(nd)forsome constantsa>0,b>1,andd0, 2There areeven more general results ofthistype,butwewillnotbeneeding them.
2âŒ˜4âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 59 Figure 2.3Eachproblem ofsizenisdivided intoasubproblems ofsizen=b. Size1Sizen=b2Sizen=bSizen Depth logbn Widthalogbn=nlogbaBranc hing factora then T(n)=8 < :O(nd) ifd>logba O(ndlogn)ifd=logba O(nlogba)ifd<logba. This single theorem tells ustherunning times ofmost ofthedivide-and-conquer procedures wearelikely touse. Proof .Toprove theclaim, let'sstart byassuming forthesake ofconvenience thatnisa power ofb.This will notinuence thenal bound inanyimportant wayÂ—after all,nisat most amultiplicative factor ofbawayfrom some power ofb(Exercise 2.2)Â—and itwillallow ustoignore therounding effect indn=be. Next, notice that thesize ofthesubproblems decreases byafactor ofbwith eachlevel ofrecursion, and therefore reachesthebase case after logbnlevels .This istheheight of therecursion tree.Itsbranc hing factor isa,sothekthlevel ofthetree ismade upofak subproblems ,eachofsizen=bk(Figure 2.3). Thetotal work done atthislevel is akOn bkd =O(nd)a bdk : Askgoes from0(the root) tologbn(the leaves), these numbers form ageometric series with
2âŒ˜5âŒ˜60 Algorithms ratioa=bd.Finding thesum ofsuchaseries inbig-Onotation iseasy (Exercise 0.2), andcomes down tothree cases . 1.Theratio islessthan1. Then theseries isdecreasing ,anditssum isjustgiven byitsrst term,O(nd). 2.Theratio isgreater than1. Theseries isincreasing anditssum isgiven byitslastterm,O(nlogba): nda bdlogbn =ndalogbn (blogbn)d =alogbn=a(logan)(logba)=nlogba: 3.Theratio isexactly 1. Inthiscase allO(logn)terms oftheseries areequal toO(nd). These cases translate directly into thethree contingencies inthetheorem statement. Binary search The ultimate divide-and-conquer algorithm is,ofcourse ,binary searc h:tond akeykina large lecontaining keysz[0;1;:::;n1]insorted order ,werst comparekwithz[n=2],and depending ontheresult werecurse either ontherst half ofthele,z[0;:::;n=21],oron thesecond half,z[n=2;:::;n1].Therecurrence now isT(n)=T(dn=2e)+O(1),whic histhe casea=1;b=2;d=0.Plugging into ourmaster theorem wegetthefamiliar solution: a running time ofjustO(logn). 2.3 Mergesort The problem ofsorting alistofnumbers lends itself immediately toadivide-and-conquer strategy: split thelistinto twohalves ,recursively sort eachhalf,and then merge thetwo sorted sublists . function mergesort (a[1:::n]) Input: Anarrayofnumbersa[1:::n] Output: Asortedversion ofthisarray ifn>1: returnmerge(mergesort (a[1:::bn=2c]),mergesort( a[bn=2c+1:::n])) else: returna The correctness ofthis algorithm isself-evident, aslong asacorrectmerge subroutine is specied. Ifwearegiven twosorted arraysx[1:::k]andy[1:::l],how doweefciently merge them into asingle sorted arrayz[1:::k+l]?Well,thevery rst element ofziseitherx[1]or y[1],whic hever issmaller .Therestofz[]canthen beconstructed recursively .
2âŒ˜6âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 61 Figure 2.4Thesequence ofmerge operations inmergesort . 23 10 16713 5102 53 137 162 5 3 7 13 1 6 10Input: 102 3 113 5 7 6 1 6 1013 32 5 7. function merge(x[1:::k];y[1:::l]) ifk=0:returny[1:::l] ifl=0:returnx[1:::k] ifx[1]y[1]: returnx[1]merge (x[2:::k];y[1:::l]) else: returny[1]merge (x[1:::k];y[2:::l]) Heredenotes concatenation. Thismerge procedure does aconstant amount ofwork per recursive call(provided therequired arrayspace isallocated inadvance), foratotal running time ofO(k+l).Thusmerge 'sarelinear ,andtheoverall time taken bymergesort is T(n)=2T(n=2)+O(n); orO(nlogn). Looking backatthemergesort algorithm, weseethat allthereal work isdone inmerg- ing,whic hdoesn't start until therecursion gets down tosingleton arrays.Thesingletons are merged inpairs ,toyield arrayswith twoelements .Then pairs ofthese 2-tuples aremerged, producing 4-tuples ,andsoon.Figure 2.4shows anexample . This viewpoint also suggests howmergesort might bemade iterative .Atanygiven mo- ment, there isasetofÂ“activeÂ” arraysÂ—initially ,thesingletonsÂ—whic haremerged inpairs to give thenext batchofactive arrays.These arrayscanbeorganized inaqueue ,andprocessed byrepeatedly removing twoarraysfrom thefront ofthequeue ,merging them, and putting theresult attheendofthequeue .
2âŒ˜7âŒ˜62 Algorithms Inthefollowing pseudocode ,theprimitive operation inject adds anelement totheend ofthequeue whileeject removes andreturns theelement atthefront ofthequeue . function iterative-merge sort(a[1:::n]) Input: elements a1;a2;:::;antobesorted Q=[](emptyqueue) fori=1ton: inject (Q;[ai]) whilejQj>1: inject (Q;merge (eject (Q);eject (Q))) returneject (Q)
2âŒ˜8âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 63 Annlognlower bound forsorting Sorting algorithms canbedepicted astrees .Theoneinthefollowing gure sorts anarrayof three elements ,a1;a2;a3.Itstarts bycomparing a1toa2and, iftherst islarger ,compares itwitha3;otherwise itcomparesa2anda3.And soon.Eventually weendupataleaf,and thisleafislabeled with thetrue order ofthethree elements asapermutation of1;2;3.For example ,ifa2<a1<a3,wegettheleaflabeled Â“213.Â” 321Yes a2<a3?a1<a2? a1<a3? a2<a3? a1<a3? 231213 312 132123No Thedepth ofthetreeÂ—the number ofcomparisons onthelongest path from root toleaf, inthiscase3Â—isexactly theworst-case time complexity ofthealgorithm. This wayoflooking atsorting algorithms isuseful because itallows onetoargue that mergesort isoptimal ,inthesense that (nlogn)comparisons arenecessary forsortingn elements . Here istheargument: Consider anysuchtree that sorts anarrayofnelements .Eachof itsleavesislabeled byapermutation off1;2;:::;ng.Infact, every permutation must appear asthelabel ofaleaf.The reason issimple: ifaparticular permutation ismissing ,what happens ifwefeed thealgorithm aninput ordered according tothissame permutation? And since there aren!permutations ofnelements ,itfollows that thetree hasatleastn!leaves. Wearealmost done: This isabinary tree,andweargued that ithasatleastn!leaves. Recall now that abinary tree ofdepthdhasatmost 2dleaves(proof: aneasy induction on d).So,thedepth ofourtreeÂ—and thecomplexity ofouralgorithmÂ—must beatleastlog(n!). And itiswell known thatlog(n!)cnlognforsomec>0.There aremany waystosee this.The easiest istonotice thatn!(n=2)(n=2)becausen!=12ncontains atleast n=2factors larger thann=2;andtothen take logsofboth sides .Another istorecall Stirling' s formula n!s  2n+1 3 nnen: Either way,wehaveestablished that anycomparison tree that sortsnelements must make , intheworst case, (nlogn)comparisons ,andhence mergesort isoptimal! Well,there issome ne print: this neat argument applies only toalgorithms that use comparisons .Isitconceivable that there arealternative sorting strategies ,perhaps using sophisticated numerical manipulations ,that work inlinear time? Theanswer isyes,under certain exceptional circumstances: thecanonical suchexample iswhen theelements tobe sorted areintegers that lieinasmall range (Exercise 2.20).
2âŒ˜9âŒ˜64 Algorithms 2.4 Medians The median ofalistofnumbers isits50thpercentile: half thenumbers arebigger than it, andhalfaresmaller .Forinstance ,themedian of[45;1;10;30;25]is25,since thisisthemiddle element when thenumbers arearranged inorder .Ifthelisthaseven length, there aretwo choices forwhat themiddle element could be,inwhic hcase wepickthesmaller ofthetwo, say. The purpose ofthemedian istosummarize asetofnumbers byasingle ,typical value . Themean ,oraverage ,isalso very commonly used forthis,butthemedian isinasense more typical ofthedata: itisalwaysoneofthedata values ,unlike themean, anditislesssensitive tooutliers .Forinstance ,themedian ofalistofahundred 1'sis(rightly) 1,asisthemean. However ,ifjustoneofthese numbers gets accidentally corrupted to10;000,themean shoots upabove 100,while themedian isunaffected. Computing themedian ofnnumbers iseasy: just sort them. The drawbac kisthat this takesO(nlogn)time,whereas wewould ideally likesomething linear .Wehavereason tobe hopeful, because sorting isdoing farmore work than wereally needÂ—we justwantthemiddle element anddon't care about therelative ordering oftherestofthem. When looking forarecursive solution, itisparadoxically often easier towork with amore general version oftheproblemÂ—for thesimple reason that thisgives amore powerful step to recurse upon. Inourcase,thegeneralization wewillconsider isselection . SELECTION Input: AlistofnumbersS;anintegerk Output: Thekthsmallest element ofS Forinstance ,ifk=1,theminimum ofSissought, whereas ifk=bjSj=2c,itisthemedian. Arandomized divide-and-conquer algorithm forselection Here' sadivide-and-conquer approac htoselection. Foranynumberv,imagine splitting listS into three categories: elements smaller thanv,those equal tov(there might beduplicates), andthose greater thanv.Call theseSL,Sv,andSRrespectively .Forinstance ,ifthearray S:236 521 813 11 20 541 issplit onv=5,thethree subarra ysgenerated are SL:241Sv:55SR:36 21 813 11 20 The searc hcaninstantly benarrowed down tooneofthese sublists .Ifwewant, say,the eighth -smallest element ofS,weknow itmust bethethird -smallest element ofSRsince jSLj+jSvj=5.That is,selection (S;8)=selection (SR;3).More generally ,bycheckingk against thesizes ofthesubarra ys,wecanquicklydetermine whic hofthem holds thedesired element: selection (S;k)=8 < :selection (SL;k) ifkjSLj v ifjSLj<kjSLj+jSvj selection (SR;kjSLjjSvj)ifk>jSLj+jSvj:
2âŒ˜10âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 65 Thethree sublistsSL;Sv,andSRcanbecomputed fromSinlinear time; infact, thiscompu- tation caneven bedone inplace ,that is,without allocating new memory (Exercise 2.15). We then recurse ontheappropriate sublist. Theeffect ofthesplit isthus toshrink thenumber of elements fromjSjtoatmost maxfjSLj;jSRjg. Ourdivide-and-conquer algorithm forselection isnow fully specied, except forthecrucial detail ofhow tochoosev.Itshould bepickedquickly,anditshould shrink thearraysubstan- tially ,theideal situation beingjSLj;jSRj1 2jSj.Ifwecould alwaysguarantee this situation, wewould getarunning time of T(n)=T(n=2)+O(n); whic hislinear asdesired. Butthisrequires pickingvtobethemedian, whic hisourultimate goal! Instead, wefollow amuchsimpler alternative: wepickvrandoml yfromS. Efciency analysis Naturally ,therunning time ofouralgorithm depends ontherandom choices ofv.Itispossible that duetopersistent badluckwekeep pickingvtobethelargest element ofthearray(orthe smallest element), andthereby shrink thearraybyonly oneelement eachtime.Intheearlier example ,wemight rst pickv=36,thenv=21,andsoon.This worst-case scenario would force ourselection algorithm toperform n+(n1)+(n2)++n 2=(n2) operations (when computing themedian), butitisextremely unlikely tooccur .Equally un- likely isthebest possible case wediscussed before ,inwhic heachrandomly chosenvjust happens tosplit thearrayperfectly inhalf,resulting inarunning time ofO(n).Where ,in thisspectrum fromO(n)to(n2),does theaverage running time lie?Fortunately ,itliesvery closetothebest-case time. Todistinguish between luckyandunluc kychoices ofv,wewillcallvgood ifitlieswithin the25thto75thpercentile ofthearraythat itischosen from. Welike these choices ofv because they ensure that thesublistsSLandSRhavesizeatmost three-fourths that ofS(do youseewhy?), sothat thearrayshrinks substantially .Fortunately ,goodv'sareabundant: half theelements ofanylistmust fallbetween the25thto75thpercentile! Given that arandomly chosenvhasa50% chance ofbeing good, how manyv'sdoweneed topickonaverage before getting agood one? Here' samore familiar reformulation (see also Exercise 1.34): Lemma Onaverage afaircoin needs tobetossed twotimes before aÂ“headsÂ” isseen. Proof .LetEbetheexpected number oftosses before aheads isseen. Wecertainly need at least onetoss,andifit'sheads ,we're done .Ifit'stails (whic hoccurs with probability 1=2),we need torepeat. HenceE=1+1 2E,whic hworks outtoE=2.
2âŒ˜11âŒ˜66 Algorithms Therefore ,after twosplit operations onaverage ,thearraywill shrink toatmost three- fourths ofitssize.LettingT(n)betheexpected running time onanarrayofsizen,weget T(n)T(3n=4)+O(n): This follows bytaking expected values ofboth sides ofthefollowing statement: Time taken onanarrayofsizen (time taken onanarrayofsize3n=4)+(time toreduce arraysizeto3n=4); and, fortheright-hand side,using thefamiliar property that theexpectation ofthesum isthe sum oftheexpectations . From this recurrence weconclude thatT(n)=O(n):onanyinput, ouralgorithm returns thecorrect answer after alinear number ofsteps ,ontheaverage . The Unixsort command Comparing thealgorithms forsorting andmedian-nding wenotice that, beyond thecom- mon divide-and-conquer philosophy andstructure ,they areexact opposites .Mergesort splits thearrayintwointhemost convenient way(rst half,second half), without anyregard to themagnitudes oftheelements ineachhalf; butthen itworks hard toputthesorted sub- arraystogether .Incontrast, themedian algorithm iscareful about itssplitting (smaller numbers rst, then thelarger ones), butitswork ends with therecursive call. Quic ksort isasorting algorithm that splits thearrayinexactly thesame wayastheme- dian algorithm; andonce thesubarra ysaresorted, bytworecursive calls,there isnothing more todo.Itsworst-case performance is(n2),likethat ofmedian-nding .Butitcanbe proved (Exercise 2.24) that itsaverage case isO(nlogn);furthermore ,empirically itoutper - forms other sorting algorithms .This hasmade quicksort afavorite inmany applicationsÂ— forinstance ,itisthebasis ofthecode bywhic hreally enormous les aresorted. 2.5 Matrix multiplication Theproduct oftwonnmatricesXandYisathirdnnmatrixZ=XY,with(i;j)thentry Zij=nX k=1XikYkj: Tomake itmore visual,Zijisthedotproduct oftheithrowofXwith thejthcolumn ofY: X Y Zij (i;j) =
2âŒ˜12âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 67 Ingeneral,XYisnotthesame asYX;matrix multiplication isnotcommutative . Thepreceding formula implies anO(n3)algorithm formatrix multiplication: there aren2 entries tobecomputed, andeachtakesO(n)time.Forquite awhile ,thiswaswidely believed tobethebest running time possible ,and itwaseven proved that incertain models ofcom- putation noalgorithm could dobetter .Itwastherefore asource ofgreat excitement when in 1969, theGerman mathematician Volker Strassen announced asignicantly more efcient algorithm, based upon divide-and-conquer . Matrix multiplication isparticularly easy tobreak into subproblems ,because itcanbe performed blockwise .Toseewhat thismeans ,carveXinto fourn=2n=2blocks,andalsoY: X=AB CD ;Y=EF GH : Then their product canbeexpressed interms ofthese blocksandisexactly asiftheblocks were single elements (Exercise 2.11). XY=AB CDEF GH =AE+BGAF+BH CE+DGCF+DH Wenow haveadivide-and-conquer strategy: tocompute thesize-nproductXY,recursively compute eight size-n=2productsAE;BG;AF;BH;CE;DG;CF;DH,andthen doafewO(n2)- time additions .Thetotal running time isdescribed bytherecurrence relation T(n)=8T(n=2)+O(n2): This comes outtoanunimpressive O(n3),thesame asforthedefault algorithm. But the efciency canbefurther improved, andaswith integer multiplication, thekeyissome clever algebra. Itturns outXYcanbecomputed from just sevenn=2n=2subproblems ,viaa decomposition sotrickyandintricate that onewonders how Strassen wasever able todiscover it! XY=P5+P4P2+P6P1+P2 P3+P4P1+P5P3P7 where P1=A(FH) P2=(A+B)H P3=(C+D)E P4=D(GE)P5=(A+D)(E+H) P6=(BD)(G+H) P7=(AC)(E+F) Thenew running time is T(n)=7T(n=2)+O(n2); whic hbythemaster theorem works outtoO(nlog27)O(n2:81).
2âŒ˜13âŒ˜68 Algorithms 2.6 The fast Fourier transform Wehavesofarseen how divide-and-conquer gives fast algorithms formultiplying integers and matrices; ournext target ispolynomials .The product oftwodegree-dpolynomials isa polynomial ofdegree 2d,forexample: (1+2x+3x2)(2+x+4x2)=2+5x+12x2+11x3+12x4: More generally ,ifA(x)=a0+a1x++adxdandB(x)=b0+b1x++bdxd,their product C(x)=A(x)B(x)=c0+c1x++c2dx2dhascoefcients ck=a0bk+a1bk1++akb0=kX i=0aibki (fori>d,takeaiandbitobezero). Computing ckfrom this formula takesO(k)steps ,and nding all2d+1coefcients would therefore seem torequire (d2)time.Can wepossibl y multipl ypolynomials faster than this? The solution wewill develop ,thefast Fourier transform, has revolutionizedÂ—indeed, denedÂ—the eld ofsignal processing (see thefollowing box). Because ofitshuge impor - tance ,and itswealth ofinsights from different elds ofstudy ,wewill approac hitalittle more leisurely than usual. Thereader who wants justthecore algorithm canskip directly to Section 2.6.4.
2âŒ˜14âŒ˜"S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 69 Why multiply polynomials? Foronething ,itturns outthat thefastest algorithms wehaveformultiplying integers rely heavilyonpolynomial multiplication; after all,polynomials and binary integers arequite similar Â—just replace thevariablexbythebase2,and watchoutforcarries .Butperhaps more importantly ,multiplying polynomials iscrucial forsignal processing . Asignal isany quantity that isafunction oftime (asinFigure (a))orofposition. It might, forinstance ,capture ahuman voice bymeasuring uctuations inairpressure close tothespeaker' smouth, oralternatively ,thepattern ofstars inthenight sky,bymeasuring brightness asafunction ofangle . a(t) t                    !! ""##$$%% &''(( )*++ , -- . //00 1122 33 45566 7899::;;<<== >?? @a(t) t AB CD EF GH IJ KL MN OP QR STSUTU VW XY Z[ \] ^_ `a bc de fTf g hi jk lTl m no pq t(t) (a) (b) (c) Inorder toextract information from asignal, weneed torst digitize itbysampling (Figure (b))Â—and, then, toputitthrough asystem that willtransform itinsome way.The output iscalled theresponse ofthesystem: signal! SYSTEM!response Animportant class ofsystems arethose that arelinear Â—the response tothesum oftwo signals isjustthesum oftheir individual responsesÂ—and time invariant Â—shifting theinput signal bytimetproduces thesame output, also shifted byt.Any system with these prop- erties iscompletely characterized byitsresponse tothesimplest possible input signal: the unit impulse(t),consisting solely ofaÂ“jerkÂ” att=0(Figure (c)). Toseethis,rst consider theclose relative(ti),ashifted impulse inwhic hthejerk occurs attimei.Any signal a(t)canbeexpressed asalinear combination ofthese ,letting(ti)pickoutitsbeha vior attimei, a(t)=T1X i=0a(i)(ti) (ifthesignal consists ofTsamples). Bylinearity ,thesystem response toinputa(t)isdeter - mined bytheresponses tothevarious(ti).And bytime invariance ,these areinturn just shifted copies oftheimpulse responseb(t),theresponse to(t). Inother words ,theoutput ofthesystem attimekis c(k)=kX i=0a(i)b(ki); exactly theformula forpolynomial multiplication!"
2âŒ˜15âŒ˜70 Algorithms 2.6.1 Analternative representation ofpolynomials Toarrive atafastalgorithm forpolynomial multiplication wetake inspiration from animpor - tant property ofpolynomials . Fact Adegree-dpolynomial isuniquely characterized byitsvalues atanyd+1distinct points . Afamiliar instance ofthis isthat Â“any twopoints determine aline.Â”Wewilllater seewhy themore general statement istrue (page 76),butforthetime being itgives usanalternative representation ofpolynomials .Fixanydistinct pointsx0;:::;xd.Wecanspecify adegree-d polynomial A(x)=a0+a1x++adxdbyeither oneofthefollowing: 1.Itscoefcients a0;a1;:::;ad 2.ThevaluesA(x0);A(x1);:::;A(xd) Ofthese tworepresentations ,thesecond isthemore attractive forpolynomial multiplication. Since theproductC(x)hasdegree 2d,itiscompletely determined byitsvalue atany2d+1 points .And itsvalue atanygiven pointziseasy enough togure out, justA(z)timesB(z). Thus polynomial multiplication takes linear time inthevalue representation. Theproblem isthat weexpect theinput polynomials ,andalsotheir product, tobespecied bycoefcients .Soweneed torst translate from coefcients tovaluesÂ—whic hisjustamatter ofevaluating thepolynomial atthechosen pointsÂ—then multiply inthevalue representation, andnally translate backtocoefcients ,aprocess called interpolation . InterpolationCoefcient representation a0;a1;:::;adValue representation A(x0);A(x1);:::;A(xd)Evaluation Figure 2.5presents theresulting algorithm. Theequivalence ofthetwopolynomial representations makes itclear that thishigh-level approac hiscorrect, buthow efcient isit?Certainly theselection step andthenmultiplica- tions arenotrouble atall,justlinear time.3But(leaving aside interpolation, about whic hwe know even less) how about evaluation? Evaluating apolynomial ofdegreednatasingle point takesO(n)steps (Exercise 2.29), andsothebaseline fornpoints is(n2).We'llnow see that thefastFourier transform (FFT) does itinjustO(nlogn)time,foraparticularly clever choice ofx0;:::;xn1inwhic hthecomputations required bytheindividual points overlap with oneanother andcanbeshared. 3Inatypical setting forpolynomial multiplication, thecoefcients ofthepolynomials arereal numbers and, moreover ,aresmall enough that basic arithmetic operations (adding and multiplying) take unit time.Wewill assume thistobethecase without anygreat lossofgenerality; inparticular ,thetime bounds weobtain areeasily adjustable tosituations with larger numbers .
2âŒ˜16âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 71 Figure 2.5Polynomial multiplication Input: Coefficients oftwopolynomials, A(x)andB(x),ofdegreed Output: TheirproductC=AB Selection Picksomepointsx0;x1;:::;xn1,wheren2d+1 Evaluation ComputeA(x0);A(x1);:::;A(xn1)andB(x0);B(x1);:::;B(xn1) Multiplication ComputeC(xk)=A(xk)B(xk)forallk=0;:::;n1 Interpolation RecoverC(x)=c0+c1x++c2dx2d 2.6.2 Evaluation bydivide-and-conquer Here' sanidea forhow topickthenpoints atwhic htoevaluate apolynomial A(x)ofdegree n1.Ifwechoose them tobepositive-negative pairs ,that is, x0;x1;:::;xn=21; then thecomputations required foreachA(xi)andA(xi)overlap alot,because theeven powers ofxicoincide with those ofxi. Toinvestigate this,weneed tosplitA(x)into itsoddandeven powers ,forinstance 3+4x+6x2+2x3+x4+10x5=(3+6x2+x4)+x(4+2x2+10x4): Notice that theterms inparentheses arepolynomials inx2.More generally , A(x)=Ae(x2)+xAo(x2); whereAe(),with theeven-numbered coefcients ,andAo(),with theodd-numbered coef- cients ,arepolynomials ofdegreen=21(assume forconvenience thatniseven). Given paired pointsxi,thecalculations needed forA(xi)canberecyc ledtowardcomputing A(xi): A(xi)=Ae(x2 i)+xiAo(x2 i) A(xi)=Ae(x2 i)xiAo(x2 i): Inother words ,evaluating A(x)atnpaired pointsx0;:::;xn=21reduces toevaluating Ae(x)andAo(x)(whic heachhavehalf thedegree ofA(x))atjustn=2points ,x2 0;:::;x2 n=21.
2âŒ˜17âŒ˜72 Algorithms Evaluate:A(x) degree n1 Ae(x)andAo(x) degree n=21at:at: x0+x1x1  x2 0xn=21 +xn=21 x2 1x2 n=21+x0 Equivalently , evaluate: The original problem ofsizenisinthis wayrecast astwosubproblems ofsizen=2,followed bysome linear -time arithmetic .Ifwecould recurse ,wewould getadivide-and-conquer pro- cedure with running time T(n)=2T(n=2)+O(n); whic hisO(nlogn),exactly what wewant. But wehaveaproblem: The plus-minus trickonly works atthetoplevel oftherecur - sion. Torecurse atthenext level, weneed then=2evaluation pointsx2 0;x2 1;:::;x2 n=21tobe themselves plus-minus pairs .Buthow canasquare benegative? Thetask seems impossible! Unless ,ofcourse,weusecomplex number s. Fine,butwhic hcomplex numbers? Togure thisout,letusÂ“reverse engineerÂ” theprocess . Atthevery bottom oftherecursion, wehaveasingle point. This point might aswell be1,in whic hcase thelevel above itmust consist ofitssquare roots ,p 1=1. 1 i 1 +1+1+i +1... Thenext level upthen hasp+1=1aswell asthecomplex numbersp1=i,wherei istheimaginary unit. Bycontinuing inthis manner ,weeventually reachtheinitial setofn points .Perhaps youhavealready guessed what they are: thecomplexnthroots ofunity ,that is,thencomplex solutions totheequationzn=1. Figure 2.6isapictorial review ofsome basic facts about complex numbers .Thethird panel ofthisgure introduces thenthroots ofunity: thecomplex numbers 1;!;!2;:::;!n1,where !=e2i=n.Ifniseven, 1.Thenthroots areplus-minus paired,!n=2+j=!j.
2âŒ˜18âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 73 2.Squaring them produces the(n=2)ndroots ofunity . Therefore ,ifwestart with these numbers forsomenthat isapower of2,then atsuccessive levels ofrecursion wewillhavethe(n=2k)throots ofunity ,fork=0;1;2;3;:::.Allthese sets ofnumbers areplus-minus paired, andsoourdivide-and-conquer ,asshown inthelastpanel, works perfectly .Theresulting algorithm isthefastFourier transform (Figure 2.7).
2âŒ˜19âŒ˜74 Algorithms Figure 2.6Thecomplex roots ofunity areideal forourdivide-and-conquer scheme .  RealImaginary ab rThe complex plane z=a+biisplotted atposition (a;b). Polar coordinates: rewrite asz=r(cos+isin)=rei, denoted (r;). lengthr=p a2+b2. angle2[0;2):cos=a=r;sin=b=r. canalwaysbereduced modulo 2. Examples:Number1i 5+5i Polar coords (1;)(1;=2)(5p 2;=4) (r1r2;1+2)(r1;1) (r2;2)Multiplying iseasy inpolar coordinates Multiply thelengths andaddtheangles: (r1;1)(r2;2)=(r1r2;1+2). Foranyz=(r;), z=(r;+)since1=(1;). Ifzisontheunit circle (i.e.,r=1),thenzn=(1;n). Angle2 n4 n 2 n+Thenthcomplex roots ofunity Solutions totheequationzn=1. Bythemultiplication rule: solutions arez=(1;),fora multiple of2=n(shown here forn=16). Forevenn: These numbers areplus-minus paired :(1;)=(1;+). Their squares arethe(n=2)ndroots ofunity ,shown here with boxes around them. Divide-and-conquer step Evaluate Ae(x);Ao(x) at(n=2)nd roots StillpairedDivide and conquer PairedEvaluate A(x) atnthroots ofunity (nisapower of2)
2âŒ˜20âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 75 Figure 2.7ThefastFourier transform (polynomial formulation) function FFT(A;!) Input: Coefficient representation ofapolynomial A(x) ofdegreen1,wherenisapowerof2 !,annthrootofunity Output: Valuerepresentation A(!0);:::;A(!n1) if!=1:returnA(1) expressA(x)intheformAe(x2)+xAo(x2) callFFT(Ae;!2)toevaluate Aeatevenpowersof! callFFT(Ao;!2)toevaluate Aoatevenpowersof! forj=0ton1: computeA(!j)=Ae(!2j)+!jAo(!2j) returnA(!0);:::;A(!n1) 2.6.3 Interpolation Let'stake stockofwhere weare.Werst developed ahigh-level scheme formultiplying polynomials (Figure 2.5), based ontheobservation that polynomials canberepresented in twoways,interms oftheir coefcients orinterms oftheir values ataselected setofpoints . InterpolationCoefcient representation a0;a1;:::;an1Value representation A(x0);A(x1);:::;A(xn1)Evaluation The value representation makes ittrivial tomultiply polynomials ,butwecannot ignore the coefcient representation since itistheform inwhic htheinput and output ofouroverall algorithm arespecied. Sowedesigned theFFT,awaytomove from coefcients tovalues intime justO(nlogn), when thepointsfxigarecomplexnthroots ofunity (1;!;!2;:::;!n1). hvaluesi=FFT(hcoefcientsi;!): Thelastremaining piece ofthepuzzle istheinverse operation, interpolation. Itwillturn out, amazingly ,that hcoefcientsi=1 nFFT(hvaluesi;!1): Interpolation isthus solved inthemost simple andelegant waywecould possibly havehoped forÂ—using thesame FFT algorithm, butcalled with!1inplace of!!This might seem likea miraculous coincidence ,butitwillmake alotmore sense when werecast ourpolynomial oper- ations inthelanguage oflinear algebra. Meanwhile ,ourO(nlogn)polynomial multiplication algorithm (Figure 2.5)isnow fully specied.
2âŒ˜21âŒ˜76 Algorithms Amatrix reformulation Togetaclearer view ofinterpolation, let'sexplicitly setdown therelationship between ourtwo representations forapolynomial A(x)ofdegreen1.They areboth vectors ofnnumbers , andoneisalinear transformation oftheother: 2 6664A(x0) A(x1) ... A(xn1)3 7775=2 66641x0x2 0xn1 0 1x1x2 1xn1 1... 1xn1x2 n1xn1 n13 77752 6664a0 a1 ... an13 7775: Call thematrix inthemiddleM.Itsspecialized formatÂ—a Vandermonde matrixÂ—gives it many remarkable properties ,ofwhic hthefollowing isparticularly relevant tous. Ifx0;:::;xn1aredistinct numbers ,thenMisinvertible . Theexistence ofM1allows ustoinvert thepreceding matrix equation soastoexpress coef- cients interms ofvalues .Inbrief , Evaluation ismultiplication byM,while interpolation ismultiplication byM1. This reformulation ofourpolynomial operations reveals their essential nature more clearly . Among other things ,itnally justies anassumption wehavebeen making throughout, that A(x)isuniquely characterized byitsvalues atanynpointsÂ—in fact, wenow haveanexplicit formula that willgive usthecoefcients ofA(x)inthissituation. Vandermonde matrices also havethedistinction ofbeing quickertoinvert than more general matrices ,inO(n2)time in- stead ofO(n3).However ,using this forinterpolation would still notbefastenough forus,so once again weturn toourspecial choice ofpointsÂ—the complex roots ofunity . Interpolation resolved Inlinear algebra terms ,theFFT multiplies anarbitraryn-dimensional vector Â—whic hwe havebeen calling thecoefcient representation Â—by thennmatrix Mn(!)=2 666666666641 1 1 1 1!!2!n1 1!2!4!2(n1) ... 1!j!2j!(n1)j ... 1!(n1)!2(n1)!(n1)(n1)3 77777777775 rowfor!0=1 ! !2 ... !j ... !n1 where!isacomplexnthroot ofunity ,andnisapower of2.Notice how simple thismatrix is todescribe: its(j;k)thentry (starting row- andcolumn-count atzero) is!jk. Multiplication byM=Mn(!)maps thekthcoordinate axis (thevector with allzeros except fora1atpositionk)onto thekthcolumn ofM.Now here' sthecrucial observation, whic hwe'll
2âŒ˜22âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 77 Figure 2.8The FFT takes points inthestandard coordinate system, whose axes areshown here asx1;x2;x3,and rotates them into theFourier basis ,whose axes arethecolumns of Mn(!),shown here asf1;f2;f3.Forinstance ,points indirectionx1getmapped into direction f1. FFT x1x3x2 f3f1 f2 prove shortly: thecolumns ofMareorthogonal (atright angles) toeachother .Therefore they canbethought ofastheaxes ofanalternative coordinate system, whic hisoften called theFourier basis .The effect ofmultiplying avector byMistorotate itfrom thestandard basis ,with theusual setofaxes,into theFourier basis ,whic hisdened bythecolumns of M(Figure 2.8). The FFT isthus achange ofbasis ,arigid rotation .The inverse ofMisthe opposite rotation, from theFourier basis backintothestandard basis .When wewrite outthe orthogonality condition precisely ,wewillbeable toread offthisinverse transformation with ease: Inversion formula Mn(!)1=1 nMn(!1). But!1isalso annthroot ofunity ,andsointerpolationÂ—or equivalently ,multiplication by Mn(!)1Â—isitself justanFFT operation, butwith!replaced by!1. Now let'sgetintothedetails .Take!tobee2i=nforconvenience ,andthink ofthecolumns ofMasvectors inCn.Recall that theangle between two vectorsu=(u0;:::;un1)and v=(v0;:::;vn1)inCnisjustascaling factor times their inner product uv=u0v 0+u1v 1++un1v n1; wherezdenotes thecomplex conjugate4ofz.This quantity ismaximized when thevectors lieinthesame direction andiszero when thevectors areorthogonal toeachother . Thefundamental observation weneed isthefollowing . Lemma Thecolumns ofmatrixMareorthogonal toeachother . Proof .Taketheinner product ofanycolumnsjandkofmatrixM, 1+!jk+!2(jk)++!(n1)(jk): 4The complex conjugate ofacomplex number z=reiisz=rei.The complex conjugate ofavector (or matrix) isobtained bytaking thecomplex conjugates ofallitsentries .
2âŒ˜23âŒ˜78 Algorithms This isageometric series with rst term1,lastterm!(n1)(jk),andratio!(jk).Therefore it evaluates to(1!n(jk))=(1!(jk)),whic his0Â—except whenj=k,inwhic hcase allterms are1andthesum isn. Theorthogonality property canbesummarized inthesingle equation MM=nI; since (MM)ijistheinner product oftheithandjthcolumns ofM(doyouseewhy?). This immediately impliesM1=(1=n)M:wehaveaninversion formula! Butisitthesame for- mula weearlier claimed? Let'sseeÂ—the (j;k)thentry ofMisthecomplex conjugate ofthe corresponding entry ofM,inother words!jk.Whereupon M=Mn(!1),andwe're done . And now wecannally step backand view thewhole affair geometrically .The task we need toperform, polynomial multiplication, isaloteasier intheFourier basis than inthe standard basis .Therefore ,werst rotate vectors into theFourier basis (evaluation ),then perform thetask (multiplication ),andnally rotate back(interpolation ).The initial vectors arecoefcient representations ,while their rotated counterparts arevalue representations .To efciently switc hbetween these ,backandforth, istheprovince oftheFFT. 2.6.4 Acloser look atthefast Fourier transform Now that ourefcient scheme forpolynomial multiplication isfully realized, let'shone in more closely onthecore subroutine that makes itallpossible ,thefastFourier transform. The denitive FFT algorithm The FFT takes asinput avectora=(a0;:::;an1)and acomplex number!whose powers 1;!;!2;:::;!n1arethecomplexnthroots ofunity .Itmultiplies vectorabythennmatrix Mn(!),whic hhas(j;k)thentry (starting row- andcolumn-count atzero)!jk.The potential forusing divide-and-conquer inthismatrix-vector multiplication becomes apparent whenM's columns aresegregated into evens andodds: = a Mn(!)an1a0 a1 a2 a3 a4 ...!jkk j =a2 a1 a3 an1...a0 ... an22k+1Column 2k Even!2jk!j!2jk columnsOdd columnsjRowja2 a1 a3 an1...a0 ... an2!2jk !2jk!j!2jk2k+1Column j+n=22k !j!2jk Inthesecond step,wehavesimplied entries inthebottom halfofthematrix using!n=2=1 and!n=1.Notice that thetopleftn=2n=2submatrix isMn=2(!2),asistheoneonthe
2âŒ˜24âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 79 Figure 2.9ThefastFourier transform function FFT(a;!) Input: Anarraya=(a0;a1;:::;an1),fornapowerof2 Aprimitive nthrootofunity,! Output: Mn(!)a if!=1:returna (s0;s1;:::;sn=21)=FFT((a0;a2;:::;an2);!2) (s0 0;s0 1;:::;s0 n=21)=FFT((a1;a3;:::;an1);!2) forj=0ton=21: rj=sj+!js0 j rj+n=2=sj!js0 j return (r0;r1;:::;rn1) bottom left. And thetopand bottom right submatrices arealmost thesame asMn=2(!2), butwith theirjthrows multiplied through by!jand!j,respectively .Therefore thenal product isthevector a0 a2... an2 a0 a2... an2Mn=2Mn=2a1 a3... an1 a1 a3... an1Mn=2 Mn=2+!j !j j+n=2Rowj Inshort, theproduct ofMn(!)with vector (a0;:::;an1),asize-nproblem, canbeexpressed interms oftwosize-n=2problems: theproduct ofMn=2(!2)with(a0;a2;:::;an2)and with (a1;a3;:::;an1).This divide-and-conquer strategy leads tothedenitive FFT algorithm of Figure 2.9,whose running time isT(n)=2T(n=2)+O(n)=O(nlogn). The fast Fourier transform unraveled Throughout allourdiscussions sofar,thefast Fourier transform hasremained tightly co- cooned within adivide-and-conquer formalism. Tofully expose itsstructure ,wenow unra vel therecursion. Thedivide-and-conquer step oftheFFT canbedrawnasavery simple circuit. Here ishow aproblem ofsizenisreduced totwosubproblems ofsizen=2(forclarity ,onepair ofoutputs (j;j+n=2)issingled out):
2âŒ˜25âŒ˜80 Algorithms a0a2 a3 j+n=2ja1 an1rj+n=2 FFT n=2FFT n=2... ...an2rjFFT n(input:a0;:::;an1,output:r0;:::;rn1) We'reusing aparticular shorthand: theedges arewires carrying complex numbers from left toright. Aweight ofjmeans Â“multiply thenumber onthiswire by!j.Â”And when twowires come into ajunction from theleft, thenumbers they arecarrying getadded up.Sothetwo outputs depicted areexecuting thecommands rj=sj+!js0 j rj+n=2=sj!js0 j from theFFT algorithm (Figure 2.9), viaapattern ofwires known asabutter y:. Unra veling theFFT circuit completely forn=8elements ,wegetFigure 10.4. Notice the following . 1.Forninputs there arelog2nlevels ,eachwithnnodes ,foratotal ofnlognoperations . 2.Theinputs arearranged inapeculiar order: 0;4;2;6;1;5;3;7. Why? Recall that atthetoplevel ofrecursion, werst bring uptheeven coefcients ofthe input andthen move ontotheoddones.Then atthenext level, theeven coefcients ofthis rst group (whic htherefore aremultiples of4,orequivalently ,havezero astheir twoleast signicant bits) arebrought up,and soon.Toputitotherwise ,theinputs arearranged by increasing lastbitofthebinary representation oftheir index, resolving tiesbylooking atthe next more signicant bit(s). The resulting order inbinary ,000;100;010;110;001;101;011;111, isthesame asthenatural one,000;001;010;011;100;101;110;111except thebitsaremirrored! 3.There isaunique path between eachinputajandeachoutputA(!k). This path ismost easily described using thebinary representations ofjandk(shown in Figure 10.4 forconvenience). There aretwoedges outofeachnode ,onegoing up(the0-edge) andonegoing down (the1-edge). TogettoA(!k)from anyinput node ,simply follow theedges specied inthebitrepresentation ofk,starting from therightmost bit. (Can yousimilarly specify thepath inthereverse direction?) 4.Onthepath betweenajandA(!k),thelabels adduptojkmod8. Since!8=1,this means that thecontribution ofinputajtooutputA(!k)isaj!jk,and therefore thecircuit computes correctly thevalues ofpolynomial A(x).
2âŒ˜26âŒ˜"S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 81 5.And nally ,notice that theFFT circuit isanatural forparallel computation anddirect implementation inhardw are. Figure 2.10 ThefastFourier transform circuit.          !""#$%&'()*+,-./a0 a4 a2 a6 a1 a5 a7A(!1) A(!2) A(!3) A(!4) A(!5) A(!6) A(!7)a3A(!0) 1 4444 6 6 74 42 263254000 100 010 110 001 101 011 111 111110101100011010001000"
2âŒ˜27âŒ˜82 Algorithms The slow spread ofafast algorithm In1963, during ameeting ofPresident Kennedy' sscientic advisors ,JohnTukey ,amath- ematician from Princeton, explained toIBM' sDickGarwin afast method forcomputing Fourier transforms .Garwin listened carefully ,because hewasatthetime working onways todetect nuclear explosions from seismographic data, andFourier transforms were thebot- tlenec kofhismethod. When hewent backtoIBM, heasked John Cooley toimplement Tukey' salgorithm; they decided that apaper should bepublished sothat theidea could not bepatented. Tukey wasnotvery keen towrite apaper onthesubject, soCooley took theinitiative . And this ishow oneofthemost famous and most cited scientic papers waspublished in 1965, co-authored byCooley andTukey .Thereason Tukey wasreluctant topublish theFFT wasnotsecretiveness orpursuit ofprot viapatents .Hejust feltthat this wasasimple observation that wasprobably already known. This wastypical oftheperiod: backthen (and forsome time later) algorithms were considered second-c lass mathematical objects , devoid ofdepth andelegance ,andunworthy ofserious attention. ButTukey wasright about onething: itwaslater discovered that British engineers had used theFFT forhand calculations during thelate1930s .AndÂ—to endthischapter with the same great mathematician who started itÂ—a paper byGauss intheearly 1800s on(what else?) interpolation contained essentially thesame idea init!Gauss' spaper hadremained a secret forsolong because itwasprotected byanold-fashioned cryptographic technique: like most scientic papers ofitsera,itwaswritten inLatin.
2âŒ˜28âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 83 Exercises 2.1. Usethedivide-and-conquer integer multiplication algorithm tomultiply thetwobinary integers 10011011 and10111010 . 2.2. Show that foranypositive integersnand anybaseb,there must some power ofblying inthe range [n;bn]. 2.3. Section 2.2describes amethod forsolving recurrence relations whic hisbased onanalyzing the recursion tree andderiving aformula forthework done ateachlevel. Another (closely related) method istoexpand outtherecurrence afewtimes ,until apattern emerges .Forinstance ,let's start with thefamiliarT(n)=2T(n=2)+O(n).Think ofO(n)asbeingcnforsome constantc, so:T(n)2T(n=2)+cn.Byrepeatedly applying thisrule,wecanboundT(n)interms ofT(n=2), thenT(n=4),thenT(n=8),andsoon,ateachstep getting closer tothevalue ofT()wedoknow , namelyT(1)=O(1). T(n)2T(n=2)+cn 2[2T(n=4)+cn=2]+cn=4T(n=4)+2cn 4[2T(n=8)+cn=4]+2cn=8T(n=8)+3cn 8[2T(n=16)+cn=8]+3cn=16T(n=16)+4cn ... Apattern isemerging ...thegeneral term is T(n)2kT(n=2k)+kcn: Plugging ink=log2n,wegetT(n)nT(1)+cnlog2n=O(nlogn). (a)Dothesame thing fortherecurrence T(n)=3T(n=2)+O(n).What isthegeneralkthterm inthiscase? And what value ofkshould beplugged intogettheanswer? (b)Now trytherecurrence T(n)=T(n1)+O(1),acase whic hisnotcovered bythemaster theorem. Can yousolve thistoo? 2.4. Suppose youarechoosing between thefollowing three algorithms: Algorithm Asolves problems bydividing them into vesubproblems ofhalf thesize,recur - sively solving eachsubproblem, andthen combining thesolutions inlinear time. Algorithm Bsolves problems ofsizenbyrecursively solving twosubproblems ofsizen1 andthen combining thesolutions inconstant time. Algorithm Csolves problems ofsizenbydividing them into nine subproblems ofsizen=3, recursively solving eachsubproblem, andthen combining thesolutions inO(n2)time. What aretherunning times ofeachofthese algorithms (inbig-Onotation), andwhic hwould you choose? 2.5. Solve thefollowing recurrence relations andgive abound foreachofthem. (a)T(n)=2T(n=3)+1 (b)T(n)=5T(n=4)+n
2âŒ˜29âŒ˜"84 Algorithms (c)T(n)=7T(n=7)+n (d)T(n)=9T(n=3)+n2 (e)T(n)=8T(n=2)+n3 (f)T(n)=49T(n=25)+n3=2logn (g)T(n)=T(n1)+2 (h)T(n)=T(n1)+nc,wherec1isaconstant (i)T(n)=T(n1)+cn,wherec>1issome constant (j)T(n)=2T(n1)+1 (k)T(n)=T(pn)+1 2.6. Alinear ,time-invariant system hasthefollowing impulse response:                ! ""# $ $% % &' ( () *+ ,- ./tb(t) t01=t0 (a)Describe inwords theeffect ofthissystem. (b)What isthecorresponding polynomial? 2.7. What isthesum ofthenthroots ofunity? What istheir product ifnisodd? Ifniseven? 2.8. Practice with thefastFourier transform. (a)What istheFFT of(1;0;0;0)?What istheappropriate value of!inthiscase? And ofwhic h sequence is(1;0;0;0)theFFT? (b)Repeat for(1;0;1;1). 2.9. Practice with polynomial multiplication byFFT. (a)Suppose that youwanttomultiply thetwopolynomials x+1andx2+1using theFFT. Choose anappropriate power oftwo,ndtheFFT ofthetwosequences ,multiply theresults componentwise ,andcompute theinverse FFT togetthenal result. (b)Repeat forthepair ofpolynomials 1+x+2x2and2+3x. 2.10. Findtheunique polynomial ofdegree 4that takes onvaluesp(1)=2,p(2)=1,p(3)=0,p(4)=4, andp(5)=0.Write your answer inthecoefcient representation. 2.11. Injustifying ourmatrix multiplication algorithm (Section 2.5), weclaimed thefollowing block- wise property: ifXandYarennmatrices ,and X=AB CD ;Y=EF GH :"
2âŒ˜30âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 85 whereA,B,C,D,E,F,G,andHaren=2n=2submatrices ,then theproductXYcanbe expressed interms ofthese blocks: XY= AB CD EF GH = AE+BGAF+BH CE+DGCF+DH Prove thisproperty . 2.12. How many lines ,asafunction ofn(in()form), does thefollowing program print? Write a recurrence andsolve it.Youmayassumenisapower of2. function f(n) ifn>1: print_line(``still going'') f(n/2) f(n/2) 2.13. Abinary tree isfullifallofitsvertices haveeither zero ortwochildren. LetBndenote the number offullbinary trees withnvertices . (a)Bydrawing outallfullbinary trees with3,5,or7vertices ,determine theexact values of B3,B5,andB7.Why haveweleftouteven numbers ofvertices ,likeB4? (b)Forgeneraln,derive arecurrence relation forBn. (c)Show byinduction thatBnis (2n). 2.14. Youaregiven anarrayofnelements ,andyounotice that some oftheelements areduplicates; that is,they appear more than once inthearray.Show how toremove allduplicates from the arrayintimeO(nlogn). 2.15. Inourmedian-nding algorithm (Section 2.4), abasic primitive isthesplit operation, whic h takes asinput anarraySand avaluevand then dividesSinto three sets: theelements less thanv,theelements equal tov,andtheelements greater thanv.Show how toimplement this split operation inplace ,that is,without allocating new memory . 2.16. Youaregiven aninnite arrayA[]inwhic htherstncells contain integers insorted order and therestofthecells arelled with1.Youarenotgiven thevalue ofn.Describe analgorithm that takes anintegerxasinput andnds aposition inthearraycontaining x,ifsuchaposition exists , inO(logn)time.(Ifyouaredisturbed bythefactthat thearrayAhasinnite length, assume instead that itisoflengthn,butthat youdon't know thislength, andthat theimplementation ofthearraydata type inyour programming language returns theerror message1whenever elementsA[i]withi>nareaccessed.) 2.17. Given asorted arrayofdistinct integersA[1;:::;n],youwanttond outwhether there isan indexiforwhic hA[i]=i.Give adivide-and-conquer algorithm that runs intimeO(logn). 2.18. Consider thetask ofsearc hing asorted arrayA[1:::n]foragiven elementx:atask weusually perform bybinary searc hintimeO(logn).Show that anyalgorithm that accesses thearrayonly viacomparisons (that is,byasking questions oftheform Â“isA[i]z?Â”),must take (logn)steps . 2.19. Ak-way merge operation. Suppose youhaveksorted arrays,eachwithnelements ,andyouwant tocombine them into asingle sorted arrayofknelements .
2âŒ˜31âŒ˜86 Algorithms (a)Here' sonestrategy: Using themerge procedure from Section 2.3,merge therst twoar- rays,then merge inthethird, then merge inthefourth, and soon. What isthetime complexity ofthisalgorithm, interms ofkandn? (b)Give amore efcient solution tothisproblem, using divide-and-conquer . 2.20. Show that anyarrayofintegersx[1:::n]canbesorted inO(n+M)time,where M=max iximin ixi: ForsmallM,thisislinear time: why doesn't the (nlogn)lower bound apply inthiscase? 2.21. Mean andmedian. One ofthemost basic tasks instatistics istosummarize asetofobservations fx1;x2;:::;xngRbyasingle number .Two popular choices forthissummary statistic are: Themedian, whic hwe'll call1 Themean, whic hwe'll call2 (a)Show that themedian isthevalue ofthat minimizes thefunction X ijxij: Youcanassume forsimplicity thatnisodd. (Hint: Show that forany6=1,thefunction decreases ifyoumoveeither slightly totheleftorslightly totheright.) (b)Show that themean isthevalue ofthat minimizes thefunction X i(xi)2: One waytodothisisbycalculus .Another method istoprove that forany2R, X i(xi)2=X i(xi2)2+n(2)2: Notice how thefunction for2penalizes points that arefarfrommuchmore heavilythan the function for1.Thus2tries muchharder tobeclosetoalltheobservations .This might sound likeagood thing atsome level, butitisstatistically undesirable because justafewoutliers can severely throw offtheestimate of2.Itistherefore sometimes said that1isamore robust estimator than2.Worse than either ofthem, however ,is1,thevalue ofthat minimizes the function max ijxij: (c)Show that1canbecomputed inO(n)time (assuming thenumbersxiaresmall enough that basic arithmetic operations onthem take unit time). 2.22. Youaregiven two sorted lists ofsizemandn.Give anO(logm+logn)time algorithm for computing thekthsmallest element intheunion ofthetwolists. 2.23. AnarrayA[1:::n]issaid tohaveamajority element ifmore than half ofitsentries arethe same .Given anarray,thetask istodesign anefcient algorithm totellwhether thearrayhasa majority element, and, ifso,tond that element. Theelements ofthearrayarenotnecessarily from some ordered domain liketheintegers ,andsothere canbenocomparisons oftheform Â“is A[i]>A[j]?Â”.(Think ofthearrayelements asGIF les,say.)However youcananswer questions oftheform: Â“isA[i]=A[j]?Â”inconstant time.
2âŒ˜32âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 87 (a)Show how tosolve thisproblem inO(nlogn)time.(Hint: Split thearrayAinto twoarrays A1andA2ofhalfthesize.Does knowing themajority elements ofA1andA2help yougure outthemajority element ofA?Ifso,youcanuseadivide-and-conquer approac h.) (b)Can yougive alinear -time algorithm? (Hint: Here' sanother divide-and-conquer approac h: Pairuptheelements ofAarbitrarily ,togetn=2pairs Look ateachpair: ifthetwoelements aredifferent, discard both ofthem; ifthey are thesame ,keep justoneofthem Show that after this procedure there areatmostn=2elements left, andthat they havea majority element ifandonly ifAdoes.) 2.24. Onpage 66there isahigh-level description ofthequicksort algorithm. (a)Write down thepseudocode forquicksort. (b)Show that itsworst-case running time onanarrayofsizenis(n2). (c)Show that itsexpected running time satises therecurrence relation T(n)O(n)+1 nn1X i=1(T(i)+T(ni)): Then, show that thesolution tothisrecurrence isO(nlogn). 2.25. InSection 2.1wedescribed analgorithm that multiplies twon-bitbinary integersxandyin timena,wherea=log23.Call thisprocedure fastmultiply (x;y). (a)Wewanttoconvert thedecimal integer 10n(a1followed bynzeros) intobinary .Here isthe algorithm (assumenisapower of2): function pwr2bin(n) ifn=1:return 1010 2 else: z=??? returnfastmultiply( z;z) Fillinthemissing details .Then give arecurrence relation fortherunning time ofthe algorithm, andsolve therecurrence . (b)Next, wewanttoconvert anydecimal integerxwithndigits (wherenisapower of2)into binary .Thealgorithm isthefollowing: function dec2bin(x) ifn=1:returnbinary [x] else: splitxintotwodecimal numbersxL,xRwithn=2digitseach return??? Herebinary []isavector that contains thebinary representation ofallone-digit integers . That is,binary [0]=02,binary [1]=12,uptobinary [9]=1001 2.Assume that alookup in binary takesO(1)time. Fillinthemissing details .Once again, give arecurrence fortherunning time ofthealgo- rithm, andsolve it.
2âŒ˜33âŒ˜88 Algorithms 2.26. Professor F.Lake tells hisclassthat itisasymptotically faster tosquare ann-bitinteger than to multiply twon-bitintegers .Should they believe him? 2.27. Thesquare ofamatrixAisitsproduct with itself ,AA. (a)Show that vemultiplications aresufcient tocompute thesquare ofa22matrix. (b)What iswrong with thefollowing algorithm forcomputing thesquare ofannnmatrix? Â“Use adivide-and-conquer approac hasinStrassen' salgorithm, except that in- stead ofgetting 7subproblems ofsizen=2,wenow get5subproblems ofsizen=2 thanks topart (a). Using thesame analysis asinStrassen' salgorithm, wecan conclude that thealgorithm runs intimeO(nlog25).Â” (c)Infact, squaring matrices isnoeasier than matrix multiplication. Inthis part, youwill show that ifnnmatrices canbesquared intimeS(n)=O(nc),then any twonn matrices canbemultiplied intimeO(nc). i.Given twonnmatricesAandB,show that thematrixAB+BAcanbecomputed in time3S(n)+O(n2). ii.Given twonnmatricesXandY,dene the2n2nmatricesAandBasfollows: A=X0 00 andB=0Y 00 : What isAB+BA,interms ofXandY? iii.Using (i)and(ii),argue that theproductXYcanbecomputed intime3S(2n)+O(n2). Conc lude that matrix multiplication takes timeO(nc). 2.28. TheHadamard matricesH0;H1;H2;:::aredened asfollows: H0isthe11matrix1 Fork>0,Hkisthe2k2kmatrix Hk=Hk1Hk1 Hk1Hk1 Show that ifvisacolumn vector oflengthn=2k,then thematrix-vector productHkvcanbe calculated usingO(nlogn)operations .Assume that allthenumbers involved aresmall enough that basic arithmetic operations likeaddition andmultiplication take unit time. 2.29. Suppose wewanttoevaluate thepolynomial p(x)=a0+a1x+a2x2++anxnatpointx. (a)Show that thefollowing simple routine ,known asHorner' srule,does thejobandleavesthe answer inz. z=an fori=n1downto 0: z=zx+ai (b)How many additions andmultiplications does thisroutine use,asafunction ofn?Can you ndapolynomial forwhic hanalternative method issubstantially better? 2.30. This problem illustrates how todotheFourier Transform (FT) inmodular arithmetic ,forexam- ple,modulo 7.
2âŒ˜34âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 89 (a)There isanumber!suchthat allthepowers!;!2;:::;!6aredistinct (modulo 7).Findthis !,andshow that!+!2++!6=0.(Interestingly ,foranyprime modulus there issuch anumber .) (b)Using thematrix form oftheFT,produce thetransform ofthesequence (0;1;1;1;5;2)mod- ulo7;that is,multiply thisvector bythematrixM6(!),forthevalue of!youfound earlier . Inthematrix multiplication, allcalculations should beperformed modulo 7. (c)Write down thematrix necessary toperform theinverse FT.Show that multiplying bythis matrix returns theoriginal sequence .(Again allarithmetic should beperformed modulo 7.) (d)Now show how tomultiply thepolynomials x2+x+1andx3+2x1using theFTmodulo 7. 2.31. InSection 1.2.3, westudied Euclid'salgorithm forcomputing thegreatest common divisor (gcd) oftwopositive integers: thelargest integer whic hdivides them both. Here wewilllook atan alternative algorithm based ondivide-and-conquer . (a)Show that thefollowing rule istrue. gcd(a;b)=8 < :2gcd(a=2;b=2) ifa;bareeven gcd(a;b=2) ifaisodd,biseven gcd((ab)=2;b)ifa;bareodd (b)Give anefcient divide-and-conquer algorithm forgreatest common divisor . (c)How does theefciency ofyour algorithm compare toEuclid'salgorithm ifaandbaren-bit integers? (Inparticular ,sincenmight belarge youcannot assume that basic arithmetic operations likeaddition take constant time.) 2.32. Inthisproblem wewilldevelop adivide-and-conquer algorithm forthefollowing geometric task. CLOSESTPAIR Input: Asetofpoints intheplane ,fp1=(x1;y1);p2=(x2;y2);:::;pn=(xn;yn)g Output: The closest pair ofpoints: that is,thepairpi6=pjforwhic hthedistance betweenpiandpj,that is,q (xixj)2+(yiyj)2; isminimized. Forsimplicity ,assume thatnisapower oftwo,andthat allthex-coordinates xiaredistinct, as arethey-coordinates . Here' sahigh-level overview ofthealgorithm: Findavaluexforwhic hexactly half thepoints havexi<x,andhalf havexi>x.Onthis basis ,split thepoints into twogroups ,LandR. Recursively ndtheclosest pair inLandinR.Saythese pairs arepL;qL2LandpR;qR2R, with distancesdLanddRrespectively .Letdbethesmaller ofthese twodistances . Itremains tobeseen whether there isapoint inLand apoint inRthat areless than distancedapart from eachother .Tothisend, discard allpoints withxi<xdorxi>x+d andsorttheremaining points byy-coordinate . Now,gothrough thissorted list,andforeachpoint, compute itsdistance totheseven sub- sequent points inthelist. LetpM;qMbetheclosest pair found inthisway.
2âŒ˜35âŒ˜90 Algorithms Theanswer isoneofthethree pairsfpL;qLg,fpR;qRg,fpM;qMg,whic hever isclosest. (a)Inorder toprove thecorrectness ofthisalgorithm, start byshowing thefollowing property: anysquare ofsizeddintheplane contains atmost four points ofL. (b)Now show that thealgorithm iscorrect. Theonly case whic hneeds careful consideration is when theclosest pair issplit betweenLandR. (c)Write down thepseudocode forthealgorithm, andshow that itsrunning time isgiven by therecurrence: T(n)=2T(n=2)+O(nlogn): Show that thesolution tothisrecurrence isO(nlog2n). (d)Can youbring therunning time down toO(nlogn)?
