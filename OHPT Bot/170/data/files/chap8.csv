ChapterâŒ˜PageâŒ˜Text
8âŒ˜0âŒ˜Chapter 8 NP-complete problems 8.1 Search problems Over thepast seven chapters wehavedeveloped algorithms fornding shortest paths and minimum spanning trees ingraphs ,matc hings inbipartite graphs ,maximum increasing sub- sequences ,maximum ows innetworks ,andsoon.Allthese algorithms areefcient ,because ineachcase their time requirement grows asapolynomial function (suchasn,n2,orn3)of thesizeoftheinput. Tobetter appreciate suchefcient algorithms ,consider thealternative: Inallthese prob- lems wearesearc hing forasolution (path, tree,matc hing,etc.)from among anexponential population ofpossibilities .Indeed,nboys canbematc hedwithngirls inn!different ways,a graph withnvertices hasnn2spanning trees ,andatypical graph hasanexponential num- berofpaths fromstot.Allthese problems could inprinciple besolved inexponential time by checking through allcandidate solutions ,onebyone.Butanalgorithm whose running time is 2n,orworse ,isallbutuseless inpractice (seethenext box). Thequest forefcient algorithms isabout nding clever waystobypass thisprocess ofexhaustive searc h,using clues from the input inorder todramatically narrow down thesearc hspace . Sofarinthisbook wehaveseen themost brilliant successes ofthisquest, algorithmic tech- niques that defeat thespecter ofexponentiality: greedy algorithms ,dynamic programming , linear programming (while divide-and-conquer typically yields faster algorithms forproblems wecanalready solve inpolynomial time). Now thetime hascome tomeet thequest' smost embarrassing and persistent failures .Weshall seesome other Â“searc hproblems ,Â”inwhic h again weareseeking asolution with particular properties among anexponential chaos ofal- ternatives .Butforthese new problems noshortcut seems possible .Thefastest algorithms we know forthem areallexponentialÂ—not substantially better than anexhaustive searc h.We now introduce some important examples . 247
8âŒ˜1âŒ˜248 Algorithms The story ofSissa and Moore According tothelegend, thegame ofchess wasinvented bytheBrahmin Sissa toamuse and teachhisking.Asked bythegrateful monarc hwhat hewanted inreturn, thewise man requested that theking place onegrain ofriceintherst square ofthechessboard, twointhesecond, four inthethird, andsoon,doubling theamount ofriceuptothe64th square .The king agreed onthespot, and asaresult hewastherst person tolearn the valuableÂ—-albeit humblingÂ—lesson ofexponential growth .Sissa' srequest amounted to264 1=18;446;744;073;709;551;615grains ofrice,enough ricetopaveallofIndia several times over! Allover nature ,from colonies ofbacteria tocells inafetus ,weseesystems that grow exponentiallyÂ—for awhile .In1798, theBritish philosopher T.Robert Malthus published an essayinwhic hhepredicted that theexponential growth (hecalled itÂ“geometric growthÂ”) ofthehuman population would soon deplete linearly growing resources ,anargument that inuenced Charles Darwin deeply .Malthus knew thefundamental factthat anexponential sooner orlater takes over anypolynomial. In1965, computer chippioneer Gordon E.Moore noticed that transistor density inchips haddoubled every year intheearly 1960s ,andhepredicted that thistrend would continue . This prediction, moderated toadoubling every 18months andextended tocomputer speed, isknown asMoore' slaw.Ithasheld remarkably well for40years .And these arethetwo root causes oftheexplosion ofinformation technology inthepast decades: Moore' slawand efcient algorithms . Itwould appear that Moore' slawprovides adisincentive fordeveloping polynomial al- gorithms .After all,ifanalgorithm isexponential, why notwaititoutuntil Moore' slaw makes itfeasible? Butinreality theexact opposite happens: Moore' slawisahuge incen- tivefordeveloping efcient algorithms ,because suchalgorithms areneeded inorder totake advantage oftheexponential increase incomputer speed. Here iswhy.If,forexample ,anO(2n)algorithm forBoolean satisability (SAT)were given anhour torun, itwould havesolved instances with 25variables backin1975, 31vari- ables onthefaster computers available in1985, 38variables in1995, andabout 45variables with today'smachines .Quite abitofprogressÂ—except that eachextra variable requires a year andahalf'swait,while theappetite ofapplications (many ofwhic hare,ironically ,re- lated tocomputer design) grows muchfaster .Incontrast, thesize oftheinstances solved byanO(n)orO(nlogn)algorithm would bemultiplied byafactor ofabout 100eachdecade . Inthecase ofanO(n2)algorithm, theinstance size solvable inaxed time would bemul- tiplied byabout 10eachdecade .Even anO(n6)algorithm, polynomial yetunappetizing , would more than double thesizeoftheinstances solved eachdecade .When itcomes tothe growth ofthesize ofproblems wecanattac kwith analgorithm, wehaveareversal: expo- nential algorithms make polynomially slow progress ,while polynomial algorithms advance exponentially fast! ForMoore' slawtobereected intheworld weneed efcient algorithms . AsSissa and Malthus knew very well, exponential expansion cannot besustained in- denitely inournite world. Bacterial colonies runoutoffood; chips hittheatomic scale . Moore' slawwillstop doubling thespeed ofourcomputers within adecade ortwo.And then progress willdepend onalgorithmic ingenuityÂ—or otherwise perhaps onnovel ideas suchas quantum computation ,explored inChapter 10.
8âŒ˜2âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 249 Satisability SATISFIABILITY,orSAT(recall Exercise 3.28 andSection 5.3), isaproblem ofgreat practical importance ,with applications ranging from chiptesting andcomputer design toimage analy- sisandsoftw areengineering .Itisalso acanonical hard problem. Here' swhat aninstance of SATlooks like: (x_y_z)(x_y)(y_z)(z_x)(x_y_z): This isaBoolean formula inconjunctive normal form (CNF) .Itisacollection ofclauses (the parentheses), eachconsisting ofthedisjunction (logical or,denoted_)ofseveral literals , where aliteral iseither aBoolean variable (suchasx)orthenegation ofone(suchasx). Asatisfying truth assignment isanassignment offalse ortrue toeachvariable sothat every clause contains aliteral whose value istrue .The SATproblem isthefollowing: given a Boolean formula inconjunctive normal form, either ndasatisfying truth assignment orelse report that none exists . Intheinstance shown previously ,setting allvariables totrue ,forexample ,satises every clause except thelast. Isthere atruth assignment that satises allclauses? Withalittle thought, itisnothard toargue that inthis particular case nosuchtruth assignment exists .(Hint :The three middle clauses constrain allthree variables tohavethe same value .)Buthow dowedecide thisingeneral? Ofcourse ,wecanalwayssearc hthrough alltruth assignments ,onebyone,butforformulas withnvariables ,thenumber ofpossible assignments isexponential, 2n. SATisatypical searc hproblem .Wearegiven aninstanceI(that is,some input data specifying theproblem athand, inthis case aBoolean formula inconjunctive normal form), andweareasked tond asolutionS(anobject that meets aparticular specication, inthis case anassignment that satises eachclause). Ifnosuchsolution exists ,wemust sayso. More specically ,asearc hproblem must havetheproperty that anyproposed solutionS toaninstanceIcanbequicklycheckedforcorrectness .What does thisentail? Foronething , Smust atleast beconcise (quic ktoread), with length polynomially bounded bythat ofI.This isclearly true inthecase ofSAT,forwhic hSisanassignment tothevariables .Toformalize thenotion ofquickchecking,wewillsaythat there isapolynomial-time algorithm that takes asinputIandSanddecides whether ornotSisasolution ofI.ForSAT,thisiseasy asitjust involves checking whether theassignment specied bySindeed satises every clause inI. Later inthischapter itwillbeuseful toshift ourvantage point andtothink ofthisefcient algorithm forchecking proposed solutions asdening thesearc hproblem. Thus: Asearc hproblem isspecied byanalgorithmCthat takes twoinputs ,aninstance Iand aproposed solutionS,and runs intime polynomial injIj.WesaySisa solution toIifandonly ifC(I;S)=true . Given theimportance ofthe SATsearc hproblem, researc hers over thepast 50years have tried hard tond efcient waystosolve it,butwithout success .The fastest algorithms we havearestillexponential ontheir worst-case inputs . Yet,interestingly ,there aretwonatural variants ofSATforwhic hwedohavegood algo- rithms .Ifallclauses contain atmost onepositive literal, then theBoolean formula iscalled
8âŒ˜3âŒ˜250 Algorithms Figure 8.1Theoptimal traveling salesman tour,shown inbold, haslength 18. 45 633 3 2412 3 aHorn formula ,andasatisfying truth assignment, ifoneexists ,canbefound bythegreedy algorithm ofSection 5.3. Alternatively ,ifallclauses haveonly twoliterals ,then graph the- orycomes into play,and SATcanbesolved inlinear time bynding thestrongly connected components ofaparticular graph constructed from theinstance (recall Exercise 3.28). Infact, inChapter 9,we'll seeadifferent polynomial algorithm forthis same special case,whic his called 2SAT. Ontheother hand, ifwearejustalittle more permissive andallow clauses tocontain three literals ,then theresulting problem, known as3SAT(anexample ofwhic hwesawearlier), once again becomes hard tosolve! The traveling salesman problem Inthetraveling salesman problem (TSP)wearegivennvertices 1;:::;nand alln(n1)=2 distances between them, aswell asabudgetb.Weareasked tondatour,acyclethat passes through every vertex exactly once,oftotal costborlessÂ—or toreport that nosuchtour exists . That is,weseek apermutation (1);:::;(n)ofthevertices suchthat when they aretoured inthisorder ,thetotal distance covered isatmostb: d(1);(2)+d(2);(3)++d(n);(1)b: SeeFigure 8.1foranexample (only some ofthedistances areshown; assume therestarevery large). Notice how wehavedened the TSPasasearc hproblem :given aninstance ,nd atour within thebudget (orreport that none exists). But why areweexpressing thetraveling salesman problem inthis way,when inreality itisanoptimization problem ,inwhic hthe shortest possible tour issought? Why dress itupassomething else? Foragood reason. Our plan inthis chapter istocompare and relate problems .The framework ofsearc hproblems ishelpful inthisregard, because itencompasses optimization problems likethe TSPinaddition totrue searc hproblems like SAT. Turning anoptimization problem intoasearc hproblem does notchange itsdifculty atall, because thetwoversions reduce tooneanother .Any algorithm that solves theoptimization
8âŒ˜4âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 251 TSPalso readily solves thesearc hproblem: nd theoptimum tour andifitiswithin budget, return it;ifnot,there isnosolution. Conversely ,analgorithm forthesearc hproblem canalso beused tosolve theoptimization problem. Toseewhy,rst suppose that wesomehow knew thecostoftheoptimum tour; then wecould nd this tour bycalling thealgorithm forthesearc hproblem, using theoptimum costasthebudget. Fine,buthow dowend theoptimum cost? Easy: Bybinary searc h!(See Exercise 8.1.) Incidentally ,there isasubtlety here: Why dowehavetointroduce abudget? Isn't any optimization problem also asearc hproblem inthesense that wearesearc hing forasolution that hastheproperty ofbeing optimal? The catchisthat thesolution toasearc hproblem should beeasy torecognize ,orasweputitearlier ,polynomial-time checkable .Given apo- tential solution tothe TSP,itiseasy tochecktheproperties Â“isatourÂ” (just checkthat each vertex isvisited exactly once) andÂ“has total lengthb.Â”Buthow could onechecktheproperty Â“isoptimalÂ”? Aswith SAT,there arenoknown polynomial-time algorithms forthe TSP,despite much effort byresearc hers over nearly acentury .Ofcourse ,there isanexponential algorithm for solving it,bytrying all(n1)!tours ,andinSection 6.6wesawafaster ,yetstillexponential, dynamic programming algorithm. The minimum spanning tree (MST)problem, forwhic hwedohaveefcient algorithms , provides astark contrast here.Tophrase itasasearc hproblem, weareagain given adistance matrix andaboundb,andareasked tond atreeTwith total weightP (i;j)2Tdijb.The TSPcanbethought ofasatough cousin ofthe MSTproblem, inwhic hthetree isnotallowed tobranc handistherefore apath.1This extra restriction onthestructure ofthetree results inamuchharder problem. Euler and Rudrata Inthesummer of1735 Leonhard Euler (pronounced Â“OilerÂ”), thefamous Swiss mathemati- cian, waswalking thebridges oftheEast Prussian town ofKÂ¨onigsberg .After awhile ,he noticed infrustration that, nomatter where hestarted hiswalk, nomatter how cleverly he continued, itwasimpossible tocross eachbridge exactly once.And from this silly ambition, theeld ofgraph theory wasborn. Euler identied atonce theroots ofthepark' sdeciency .First, youturn themap ofthe park intoagraph whose vertices arethefour land masses (two islands ,twobanks) andwhose edges aretheseven bridges: 1Actually the TSPdemands acycle,butonecandene analternative version that seeks apath, anditisnot hard toseethat thisisjustashard asthe TSPitself .
8âŒ˜5âŒ˜252 Algorithms Southern bankNorthern bank Small islandBig island This graph hasmultiple edges between twoverticesÂ—a feature wehavenotbeen allowing so farinthisbook, butonethat ismeaningful forthisparticular problem, since eachbridge must beaccounted forseparately .Wearelooking forapath that goes through eachedge exactly once (the path isallowed torepeat vertices). Inother words ,weareasking this question: Whencanagraph bedrawn without lifting thepencil from thepaper? The answer discovered byEuler issimple ,elegant, and intuitive: Ifand onlyif(a)the graph isconnected and (b)every vertex, with thepossible exception oftwovertices (the start andnal vertices ofthewalk), haseven degree (Exercise 3.26). This iswhy KÂ¨onigsberg' spark wasimpossible totraverse: allfour vertices haveodddegree . Toputitinterms ofourpresent concerns ,letusdene asearc hproblem called EULER PATH:Given agraph, ndapath that contains eachedge exactly once.Itfollows from Euler' s observation, andalittle more thinking ,that thissearc hproblem canbesolved inpolynomial time. Almost amillennium before Euler' sfateful summer inEast Prussia, aKashmiri poet named Rudrata had asked this question: Can onevisit allthesquares ofthechessboard, without repeating anysquare ,inonelong walkthat ends atthestarting square andateach step makes alegal knight move? This isagain agraph problem: thegraph now has64ver- tices,and twosquares arejoined byanedge ifaknight cangofrom onetotheother ina single move (that is,iftheir coordinates differ by2inonedimension andby1intheother). SeeFigure 8.2fortheportion ofthegraph corresponding totheupper leftcorner oftheboard. Can youndaknight' stour onyour chessboard? This isadifferent kind ofsearc hproblem ingraphs: wewantacyclethat goes through all vertices (asopposed toalledges inEuler' sproblem), without repeating anyvertex. And there isnoreason tosticktochessboards; thisquestion canbeasked ofanygraph. Letusdene the RUDRATACYCLEsearc hproblem tobethefollowing: given agraph, nd acyclethat visits eachvertex exactly onceÂ—or report that nosuchcycleexists .2This problem isominously reminiscent ofthe TSP,andindeed nopolynomial algorithm isknown forit. There aretwodifferences between thedenitions oftheEuler andRudrata problems .The rst isthat Euler' sproblem visits alledges while Rudrata' svisits allvertices .But there is 2Intheliterature this problem isknown astheHamilton cycle problem, after thegreat Irish mathematician who rediscovered itinthe19th century .
8âŒ˜6âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 253 Figure 8.2Knight' smoves onacorner ofachessboard. also theissue that oneofthem demands apath while theother requires acycle.Whic hof these differences accounts forthehuge disparity incomputational complexity between the twoproblems? Itmust betherst, because thesecond difference canbeshown tobepurely cosmetic .Indeed, dene theRUDRATAPATHproblem tobejustlikeRUDRATACYCLE,except that thegoal isnow tondapath that goes through eachvertex exactly once.Aswewillsoon see,there isaprecise equivalence between thetwoversions oftheRudrata problem. Cuts and bisections Acutisasetofedges whose removal leavesagraph disconnected. Itisoften ofinterest tond small cuts,andthe MINIMUMCUTproblem is,given agraph andabudgetb,tondacutwith atmostbedges .Forexample ,thesmallest cutinFigure 8.3isofsize3.This problem canbe solved inpolynomial time byn1max-ow computations: give eachedge acapacity of1,and nd themaximum ow between some xed node andevery single other node .The smallest suchow willcorrespond (viathemax-ow min-cut theorem) tothesmallest cut.Can yousee why? We'vealso seen avery different, randomized algorithm forthisproblem (page 150). Inmany graphs ,suchastheoneinFigure 8.3,thesmallest cutleavesjust asingleton vertex ononesideÂ—it consists ofalledges adjacent tothis vertex. Farmore interesting are small cuts that partition thevertices ofthegraph intonearly equal-sized sets.More precisely , the BALANCEDCUTproblem isthis: given agraph withnvertices andabudgetb,partition thevertices into twosetsSandTsuchthatjSj;jTjn=3andsuchthat there areatmostb edges betweenSandT.Another hard problem. Balanced cuts arise inavariety ofimportant applications ,suchasclustering .Consider forexample theproblem ofsegmenting animage into itsconstituent components (say,an elephant standing inagrassy plain with aclear blue skyabove). Agood wayofdoing thisis tocreate agraph with anode foreachpixel oftheimage andtoputanedge between nodes whose corresponding pixels arespatially closetogether andarealso similar incolor .Asingle
8âŒ˜7âŒ˜254 Algorithms Figure 8.3What isthesmallest cutinthisgraph? object intheimage (like theelephant, say)then corresponds toasetofhighly connected vertices inthegraph. Abalanced cutistherefore likely todivide thepixels into twoclusters without breaking apart anyoftheprimary constituents oftheimage .Therst cutmight, for instance ,separate theelephant ontheonehand from theskyandfrom grass ontheother .A further cutwould then beneeded toseparate theskyfrom thegrass . Integer linear programming Even though thesimplex algorithm isnotpolynomial time,wementioned inChapter 7that there isadifferent, polynomial algorithm forlinear programming .Therefore ,linear pro- gramming isefciently solvable both inpractice and intheory .But thesituation changes completely if,inaddition tospecifying alinear objective function andlinear inequalities ,we also constrain thesolution (the values forthevariables) tobeinteger .This latter problem iscalled INTEGERLINEARPROGRAMMING(ILP).Let'sseehow wemight formulate itasa searc hproblem. Wearegiven asetoflinear inequalities Axb,where Aisanmnmatrix andbisanm-vector; anobjective function specied byann-vector c;andnally ,agoalg(the counterpart ofabudget inmaximization problems). Wewanttond anonnegative integer n-vector xsuchthatAxbandcxg. Butthere isaredundancy here: thelastconstraint cxgisitself alinear inequality andcanbeabsorbed intoAxb.So,wedene ILPtobefollowing searc hproblem: givenA andb,nd anonnegative integer vector xsatisfying theinequalities Axb,orreport that none exists .Despite themany crucial applications ofthis problem, and intense interest by researc hers,noefcient algorithm isknown forit. There isaparticularly clean special case ofILPthat isvery hard inandofitself: thegoal is tondavector xof0'sand1'ssatisfying Ax=1,where Aisanmnmatrix with01entries and1isthem-vector ofall1's.Itshould beapparent from thereductions inSection 7.1.4 that thisisindeed aspecial case ofILP.WecallitZERO-ONEEQUATIONS(ZOE). Wehavenow introduced anumber ofimportant searc hproblems ,some ofwhic harefa- miliar from earlier chapters and forwhic hthere areefcient algorithms ,and others whic h aredifferent insmall butcrucial waysthat make them very hard computational problems .To
8âŒ˜8âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 255 Figure 8.4Amore elaborate matc hmaking scenario .Eachtriple isshown asatriangular - shaped node joining boy,girl, andpet. Armadillo BobcatCarolBeatriceAlice Chet Bob Al Canary complete ourstory wewillintroduce afewmore hard problems ,whic hwillplayarole later inthechapter ,when werelate thecomputational difculty ofallthese problems .Thereader isinvited toskip ahead toSection 8.2andthen return tothedenitions ofthese problems as required. Three-dimensional matching Recall the BIPARTITEMATCHINGproblem: given abipartite graph withnnodes oneachside (the boys and thegirls),nd asetofndisjoint edges ,ordecide that nosuchsetexists .In Section 7.3, wesawhow toefciently solve this problem byareduction tomaximum ow. However ,there isaninteresting generalization, called 3DMATCHING,forwhic hnopolyno- mial algorithm isknown. Inthis new setting ,there arenboys andngirls,butalsonpets, andthecompatibilities among them arespecied byasetoftriples ,eachcontaining aboy,a girl, andapet. Intuitively ,atriple (b;g;p)means that boyb,girlg,andpetpgetalong well together .Wewanttondndisjoint triples andthereby createnharmonious households . Can youspot asolution inFigure 8.4? Independent set,vertex cover ,and clique Inthe INDEPENDENTSETproblem (recall Section 6.7)wearegiven agraph andanintegerg, andtheaimistondgvertices that areindependent, that is,notwoofwhic hhaveanedge between them. Can yound anindependent setofthree vertices inFigure 8.5? How about four vertices? WesawinSection 6.7that this problem canbesolved efciently ontrees ,but forgeneral graphs nopolynomial algorithm isknown. There aremany other searc hproblems about graphs .InVERTEXCOVER,forexample ,the input isagraph and abudgetb,and theidea istondbvertices that cover (touc h)every edge.Can youcover alledges ofFigure 8.5with seven vertices? Withsix? (And doyouseethe
8âŒ˜9âŒ˜256 Algorithms Figure 8.5What isthesizeofthelargest independent setinthisgraph? intimate connection tothe INDEPENDENTSETproblem?) VERTEXCOVERisaspecial case ofSETCOVER,whic hweencountered inChapter 5.In that problem, wearegiven asetEandseveral subsets ofit,S1;:::;Sm,along with abudget b.Weareasked toselectbofthese subsets sothat their union isE.VERTEXCOVERisthe special case inwhic hEconsists oftheedges ofagraph, and there isasubsetSiforeach vertex, containing theedges adjacent tothat vertex. Can youseewhy 3DMATCHINGisalso aspecial case ofSETCOVER? And nally there isthe CLIQUEproblem: given agraph andagoalg,nd asetofgver- tices suchthat allpossible edges between them arepresent. What isthelargest clique in Figure 8.5? Longest path Weknow theshortest-path problem canbesolved very efciently ,buthow about the LONGEST PATHproblem? Here wearegiven agraphGwith nonnegative edge weights andtwodistin- guished verticessandt,along with agoalg.Weareasked tondapath fromstotwith total weight atleastg.Naturally ,toavoid trivial solutions werequire that thepath besimple , containing norepeated vertices . Noefcient algorithm isknown forthisproblem (whic hsometimes also goes bythename ofTAXICABRIP-OFF). Knapsack and subset sum Recall the KNAPSACKproblem (Section 6.4): wearegiven integer weightsw1;:::;wnand integer valuesv1;:::;vnfornitems .Wearealso given aweight capacityWandagoalg(the former ispresent intheoriginal optimization problem, thelatter isadded tomake itasearc h problem). Weseek asetofitems whose total weight isatmostWandwhose total value isat leastg.Asalways,ifnosuchsetexists ,weshould sayso. InSection 6.4,wedeveloped adynamic programming scheme forKNAPSACKwith running
8âŒ˜10âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 257 timeO(nW),whic hwenoted isexponential intheinput size,since itinvolvesWrather than logW.And wehavetheusual exhaustive algorithm aswell, whic hlooks atallsubsets of itemsÂ—all 2nofthem. Isthere apolynomial algorithm forKNAPSACK?Nobody knows ofone. Butsuppose that weareinterested inthevariant oftheknapsac kproblem inwhic hthe integers arecoded inunary Â—for instance ,bywritingIIIIIIIIIIIIfor12.This isadmittedly anexponentially wasteful waytorepresent integers ,butitdoes dene alegitimate problem, whic hwecould call UNARYKNAPSACK.Itfollows from ourdiscussion that this somewhat articial problem does haveapolynomial algorithm. Adifferent variation: suppose now that eachitem' svalue isequal toitsweight (allgiven in binary), andtotopitoff,thegoalgisthesame asthecapacityW.(Toadapt thesilly break-in story whereby werst introduced theknapsac kproblem, theitems areallgold nuggets ,and theburglar wants tollhisknapsac ktothehilt.) This special case istantamount tonding asubset ofagiven setofintegers that adds uptoexactlyW.Since itisaspecial case of KNAPSACK,itcannot beanyharder .Butcould itbepolynomial? Asitturns out,thisproblem, called SUBSETSUM,isalso very hard. Atthis point onecould ask: IfSUBSETSUMisaspecial case that happens tobeashard asthegeneral KNAPSACKproblem, why areweinterested init?Thereason issimplicity .In thecomplicated calculus ofreductions between searc hproblems that weshall develop inthis chapter ,conceptually simple problems like SUBSETSUMand3SATareinvaluable . 8.2 NP-complete problems Hard problems, easy problems Inshort, theworld isfullofsearc hproblems ,some ofwhic hcanbesolved efciently ,while others seem tobevery hard. This isdepicted inthefollowing table . Hard problems (NP-complete) Easy problems (inP) 3SAT 2SAT,HORNSAT TRAVELINGSALESMANPROBLEM MINIMUMSPANNINGTREE LONGESTPATH SHORTESTPATH 3DMATCHING BIPARTITEMATCHING KNAPSACK UNARYKNAPSACK INDEPENDENTSET INDEPENDENTSETontrees INTEGERLINEARPROGRAMMING LINEARPROGRAMMING RUDRATAPATH EULERPATH BALANCEDCUT MINIMUMCUT This table isworth contemplating .Ontheright wehaveproblems that canbesolved efciently .Ontheleft,wehaveabunc hofhard nuts that haveescaped efcient solution over many decades orcenturies .
8âŒ˜11âŒ˜258 Algorithms The various problems ontheright canbesolved byalgorithms that arespecialized and diverse: dynamic programming ,network ow,graph searc h,greedy .These problems areeasy foravariety ofdifferent reasons . Instark contrast, theproblems ontheleftarealldifcult forthesame reason! Attheir core,they areallthesame problem, justindifferent disguises! They areallequivalent: aswe shall seeinSection 8.3,eachofthem canbereduced toanyoftheothersÂ—and back. Pand NP It'stime tointroduce some important concepts .Weknow what asearc hproblem is:itsden- ingcharacteristic isthat anyproposed solution canbequicklycheckedforcorrectness ,inthe sense that there isanefcient checking algorithmCthat takes asinput thegiven instanceI (the data specifying theproblem tobesolved), aswell astheproposed solutionS,andoutputs true ifandonly ifSreally isasolution toinstanceI.Moreover therunning time ofC(I;S) isbounded byapolynomial injIj,thelength oftheinstance .Wedenote theclass ofallsearc h problems byNP. We'veseen many examples ofNPsearc hproblems that aresolvable inpolynomial time. Insuchcases ,there isanalgorithm that takes asinput aninstanceIandhasarunning time polynomial injIj.IfIhasasolution, thealgorithm returns suchasolution; andifIhasno solution, thealgorithm correctly reports so.Theclass ofallsearc hproblems that canbesolved inpolynomial time isdenoted P.Hence ,allthesearc hproblems ontheright-hand side ofthe table areinP. Why Pand NP? Okay,Pmust stand forÂ“polynomial. Â”Butwhy usetheinitials NP(the common chatroom abbreviation forÂ“noproblemÂ”) todescribe theclass ofsearc hproblems ,some ofwhic hare terribly hard? NPstands forÂ“nondeterministic polynomial time,Â”aterm going backtotheroots of complexity theory .Intuitively ,itmeans that asolution toanysearc hproblem canbefound andveried inpolynomial time byaspecial (and quite unrealistic) sortofalgorithm, called a nondeterministic algorithm .Suchanalgorithm hasthepower ofguessing correctly atevery step. Incidentally ,theoriginal denition ofNP(and itsmost common usage tothis day)was notasaclass ofsearc hproblems ,butasaclass ofdecision problems: algorithmic questions that canbeanswered byyesorno.Example: Â“Isthere atruth assignment that satises this Boolean formula?Â” Butthis tooreects ahistorical reality: Atthetime thetheory ofNP- completeness wasbeing developed, researc hers inthetheory ofcomputation were interested informal languages ,adomain inwhic hsuchdecision problems areofcentral importance . Are there searc hproblems that cannot besolved inpolynomial time? Inother words , isP6=NP?Most algorithms researc hers think so.Itishard tobelieve that exponential searc hcanalwaysbeavoided, that asimple trickwillcrackallthese hard problems ,famously unsolved fordecades andcenturies .And there isagood reason formathematicians tobelieve
8âŒ˜12âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 259 that P6=NPÂ—the task ofnding aproof foragiven mathematical assertion isasearc h problem andistherefore inNP(after all,when aformal proof ofamathematical statement is written outinexcruciating detail, itcanbecheckedmechanically ,linebyline,byanefcient algorithm). SoifP=NP,there would beanefcient method toprove anytheorem, thus eliminating theneed formathematicians! Allinall,there areavariety ofreasons why itis widely believed that P6=NP.However ,proving thishasturned outtobeextremely difcult, oneofthedeepest andmost important unsolved puzzles ofmathematics . Reductions, again Even ifweaccept that P6=NP,what about thespecic problems ontheleftside ofthe table? Onthebasis ofwhat evidence dowebelieve that these particular problems haveno efcient algorithm (besides ,ofcourse ,thehistorical fact that many clever mathematicians and computer scientists havetried hard and failed tond any)? Suchevidence isprovided byreductions ,whic htranslate onesearc hproblem into another .What they demonstrate is that theproblems ontheleftside ofthetable areall,insome sense ,exactl ythesame problem , except that they arestated indifferent languages .What' smore ,wewillalsousereductions to show that these problems arethehardest searc hproblems inNPÂ—ifeven oneofthem hasa polynomial time algorithm, then every problem inNPhasapolynomial time algorithm. Thus ifwebelieve that P6=NP,then allthese searc hproblems arehard. Wedened reductions inChapter 7andsawmany examples ofthem. Let'snow specialize this denition tosearc hproblems .Areduction from searc hproblemAtosearc hproblemB isapolynomial-time algorithmfthat transforms anyinstanceIofAinto aninstancef(I)of B,together with another polynomial-time algorithmhthat maps anysolutionSoff(I)back into asolutionh(S)ofI;seethefollowing diagram. Iff(I)hasnosolution, then neither does I.These twotranslation procedures fandhimply that anyalgorithm forBcanbeconverted into analgorithm forAbybracketing itbetweenfandh. IInstanceInstance f(I)fAlgorithm forA forBAlgorithmSolution Soff(I) Nosolution tof(I)Nosolution toIh(S)ofISolutionh And now wecannally dene theclassofthehardest searc hproblems . Asearc hproblem isNP-complete ifallother searc hproblems reduce toit. This isavery strong requirement indeed. Foraproblem tobeNP-complete ,itmust beuseful insolving every searc hproblem intheworld! Itisremarkable that suchproblems exist. Butthey do,andtherst column ofthetable wesawearlier islled with themost famous examples .InSection 8.3weshall seehow allthese problems reduce tooneanother ,andalso why allother searc hproblems reduce tothem.
8âŒ˜13âŒ˜260 Algorithms Figure 8.6Thespace NPofallsearc hproblems ,assuming P6=NP. NPâˆ’ Increasing difficultyP complete The two ways tousereductions Sofarinthis book thepurpose ofareduction from aproblemAtoaproblemBhasbeen straightforw ardandhonorable: Weknow how tosolveBefciently ,andwewanttousethis knowledge tosolveA.Inthis chapter ,however ,reductions fromAtoBserve asomewhat perverse goal: weknowAishard, andweusethereduction toprove thatBishard aswell! Ifwedenote areduction fromAtoBby A!B then wecansaythat difculty ows inthedirection ofthearrow ,while efcient algorithms move intheopposite direction. Itisthrough this propagation ofdifculty that weknow NP-complete problems arehard: allother searc hproblems reduce tothem, and thus eachNP-complete problem contains thecomplexity ofallsearc hproblems .Ifeven one NP-complete problem isinP,then P=NP. Reductions also havetheconvenient property that they compose . IfA!BandB!C,thenA!C. Toseethis,observe rst ofallthat any reduction iscompletely specied bythepre- and postprocessing functionsfandh(see thereduction diagram). If(fAB;hAB)and(fBC;hBC) dene thereductions fromAtoBandfromBtoC,respectively ,then areduction fromAto Cisgiven bycompositions ofthese functions: fBCfABmaps aninstance ofAtoaninstance ofCandhABhBCsends asolution ofCbacktoasolution ofA. This means that once weknow aproblemAisNP-complete ,wecanuseittoprove that anew searc hproblemBisalsoNP-complete ,simply byreducingAtoB.Suchareduction establishes that allproblems inNPreduce toB,viaA.
8âŒ˜14âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 261 Factoring One lastpoint: westarted offthisbook byintroducing another famously hard searc hproblem: FACTORING,thetask ofnding allprime factors ofagiven integer .But thedifculty of FACTORINGisofadifferent nature than that oftheother hard searc hproblems wehavejust seen. Forexample ,nobody believes that FACTORINGisNP-complete .One major difference isthat, inthecase ofFACTORING,thedenition does notcontain thenow familiar clause Â“or report that none exists .Â”Anumber canalways befactored into primes . Another difference (possibly notcompletely unrelated) isthis: asweshall seeinChap- ter10, FACTORINGsuccumbs tothepower ofquantum computation Â—while SAT,TSPandthe other NP-complete problems donotseem to.
8âŒ˜15âŒ˜262 Algorithms Figure 8.7Reductions between searc hproblems . 3DMATCHING RUDRATACYCLE SUBSETSUM TSPILPZOEAllofNP SAT 3SAT VERTEXCOVERINDEPENDENTSET CLIQUE 8.3 The reductions Weshall now seethat thesearc hproblems ofSection 8.1canbereduced tooneanother as depicted inFigure 8.7.Asaconsequence ,they areallNP-complete . Before wetacklethespecic reductions inthetree,let'swarm upbyrelating twoversions oftheRudrata problem. RUDRATA(s;t)-PATH!RUDRATACYCLE Recall theRUDRATACYCLEproblem: given agraph, isthere acyclethat passes through each vertex exactly once? Wecanalso formulate theclosely related RUDRATA(s;t)-PATHproblem, inwhic htwoverticessandtarespecied, andwewantapath starting atsandending att that goes through eachvertex exactly once.Isitpossible that RUDRATACYCLEiseasier than RUDRATA(s;t)-PATH?Wewillshow byareduction that theanswer isno. Thereduction maps aninstance (G=(V;E);s;t)ofRUDRATA(s;t)-PATHinto aninstance G0=(V0;E0)ofRUDRATACYCLEasfollows:G0issimplyGwith anadditional vertexxand twonew edgesfs;xgandfx;tg.Forinstance: G G0 s t ts x
8âŒ˜16âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 263 SoV0=V[fxg,andE0=E[ffs;xg;fx;tgg.How dowerecover aRudrata (s;t)-path inG given anyRudrata cycle inG0?Easy ,wejustdelete theedgesfs;xgandfx;tgfrom thecycle. Instance: nodes s;tG=(V;E) fs;xg;fx;tgG0=(V0;E0)RUDRATA CYCLEandedgesfs;xg;fx;tg NosolutionSolution: path Add nodexSolution: cycle NosolutionDelete edgesRUDRATA(s;t)-PATH Toconrm thevalidity ofthisreduction, wehavetoshow that itworks inthecase ofeither outcome depicted. 1.When theinstance ofRUDRATACYCLEhasasolution. Since thenew vertexxhasonly twoneighbors ,sandt,anyRudrata cycleinG0must consec- utively traverse theedgesft;xgandfx;sg.The rest ofthecyclethen traverses every other vertex enroute fromstot.Thus deleting thetwoedgesft;xgandfx;sgfrom theRudrata cyclegives aRudrata path fromstotintheoriginal graphG. 2.When theinstance ofRUDRATACYCLEdoes nothaveasolution. Inthis case wemust show that theoriginal instance ofRUDRATA(s;t)-PATHcannot havea solution either .Itisusually easier toprove thecontrapositive ,that is,toshow that ifthere is aRudrata (s;t)-path inG,then there isalso aRudrata cycleinG0.Butthisiseasy: justadd thetwoedgesft;xgandfx;sgtotheRudrata path toclosethecycle. One last detail, crucial buttypically easy tocheck,isthat thepre- and postprocessing functions take time polynomial inthesizeoftheinstance (G;s;t). Itisalso possible togointheother direction and reduce RUDRATACYCLEtoRUDRATA (s;t)-PATH.Together ,these reductions demonstrate that thetwo Rudrata variants arein essence thesame problemÂ—whic hisnottoosurprising ,given that their descriptions areal- most thesame .Butmost oftheother reductions wewillseearebetween pairs ofproblems that, ontheface ofit,look quite different. Toshow that they areessentially thesame ,our reductions willhavetocleverly translate between them. 3SAT!INDEPENDENTSET One canhardly think oftwomore different problems .In3SATtheinput isasetofclauses , eachwith three orfewer literals ,forexample (x_y_z)(x_y_z)(x_y_z)(x_y); and theaim istond asatisfying truth assignment. InINDEPENDENTSETtheinput isa graph and anumberg,and theproblem istond asetofgpairwise non-adjacent vertices . Wemust somehow relate Boolean logic with graphs!
8âŒ˜17âŒ˜264 Algorithms Figure 8.8Thegraph corresponding to(x_y_z)(x_y_z)(x_y_z)(x_y). y y y x z x z x z xy Letusthink. Toform asatisfying truth assignment wemust pickoneliteral from each clause andgive itthevaluetrue .Butourchoices must beconsistent: ifwechoosexinone clause ,wecannot choosexinanother .Any consistent choice ofliterals ,onefrom eachclause , species atruth assignment (variables forwhic hneither literal hasbeen chosen cantake on either value). So,letusrepresent aclause ,say(x_y_z),byatriangle ,with vertices labeledx;y;z.Why triangle? Because atriangle hasitsthree vertices maximally connected, andthus forces us topickonly oneofthem fortheindependent set. Repeat this construction forallclausesÂ—a clause with twoliterals willberepresented simply byanedge joining theliterals .(Aclause with oneliteral issilly and canberemoved inapreprocessing step,since thevalue ofthe variable isdetermined.) Intheresulting graph, anindependent sethastopickatmost one literal from eachgroup (clause). Toforce exactly onechoice from eachclause ,take thegoalg tobethenumber ofclauses; inourexample ,g=4. Allthat ismissing now isawaytoprevent usfrom choosing opposite literals (that is,both xandx)indifferent clauses .But this iseasy: putanedge between anytwovertices that correspond toopposite literals .Theresulting graph forourexample isshown inFigure 8.8. Let'srecap theconstruction. Given aninstanceIof3SAT,wecreate aninstance (G;g)of INDEPENDENTSETasfollows . GraphGhasatriangle foreachclause (orjust anedge,iftheclause hastwoliterals), with vertices labeled bytheclause' sliterals ,andhasadditional edges between anytwo vertices that represent opposite literals . Thegoalgissettothenumber ofclauses . Clearly ,this construction takes polynomial time.However ,recall that forareduction we donotjust need anefcient waytomap instances oftherst problem toinstances ofthe second (the functionfinthediagram onpage 259), butalso awaytoreconstruct asolution totherst instance from anysolution ofthesecond (the functionh).Asalways,there aretwo things toshow . 1.Given anindependent setSofgvertices inG,itispossible toefciently recover asatis- fying truth assignment toI.
8âŒ˜18âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 265 Foranyvariablex,thesetScannot contain vertices labeled bothxandx,because anysuch pair ofvertices isconnected byanedge.Soassignxavalue oftrue ifScontains avertex labeledx,and avalue offalse ifScontains avertex labeledx(ifScontains neither ,then assign either value tox).SinceShasgvertices ,itmust haveonevertex perclause; thistruth assignment satises those particular literals ,andthus satises allclauses . 2.IfgraphGhasnoindependent setofsizeg,then theBoolean formulaIisunsatisable . Itisusually cleaner toprove thecontrapositive ,that ifIhasasatisfying assignment thenG hasanindependent setofsizeg.This iseasy: foreachclause ,pickanyliteral whose value under thesatisfying assignment istrue (there must beatleast onesuchliteral), andaddthe corresponding vertex toS.Doyouseewhy setSmust beindependent? SAT!3SAT This isaninteresting andcommon kind ofreduction, from aproblem toaspecial case ofitself . Wewanttoshow that theproblem remains hard even ifitsinputs arerestricted somehowÂ—in thepresent case,even ifallclauses arerestricted tohave3literals .Suchreductions modify thegiven instance soastogetridoftheforbidden feature (clauses with4literals) while keeping theinstance essentially thesame ,inthat wecanread offasolution totheoriginal instance from anysolution ofthemodied one. Here' sthetrickforreducing SATto3SAT:given aninstanceIofSAT,useexactly thesame instance for3SAT,except that anyclause with more than three literals ,(a1_a2__ak) (where theai'sareliterals andk>3),isreplaced byasetofclauses , (a1_a2_y1)(y1_a3_y2)(y2_a4_y3)(yk3_ak1_ak); where theyi'sarenew variables .Call theresulting 3SATinstanceI0.The conversion fromI toI0isclearly polynomial time. Why does this reduction work?I0isequivalent toIinterms ofsatisability ,because for anyassignment totheai's, (a1_a2__ak) issatised ()8 < :there isasetting oftheyi'sforwhic h (a1_a2_y1)(y1_a3_y2)(yk3_ak1_ak) areallsatised9 = ; Toseethis,rst suppose that theclauses ontheright areallsatised. Then atleast oneoftheliteralsa1;:::;akmust betrueÂ—otherwise y1would havetobetrue,whic hwould inturn forcey2tobetrue,and soon,eventually falsifying thelast clause .But this means (a1_a2__ak)isalso satised. Conversely ,if(a1_a2__ak)issatised, then someaimust betrue.Sety1;:::;yi2to true andtheresttofalse .This ensures that theclauses ontheright areallsatised. Thus ,anyinstance ofSATcanbetransformed intoanequivalent instance of3SAT.Infact, 3SATremains hard even under thefurther restriction that novariable appears inmore than
8âŒ˜19âŒ˜266 Algorithms Figure 8.9Sisavertex cover ifandonly ifVSisanindependent set. S three clauses .Toshow this,wemust somehow getridofanyvariable that appears toomany times . Here' sthereduction from 3SATtoitsconstrained version. Suppose that inthe3SATin- stance ,variablexappears ink>3clauses .Then replace itsrst appearance byx1,itssecond appearance byx2,andsoon,replacing eachofitskappearances byadifferent new variable . Finally ,addtheclauses (x1_x2)(x2_x3)(xk_x1): And repeat forevery variable that appears more than three times . Itiseasy toseethat inthenew formula novariable appears more than three times (and infact, noliteral appears more than twice). Furthermore ,theextra clauses involv- ingx1;x2;:::;xkconstrain these variables tohavethesame value; doyouseewhy? Hence the original instance of3SATissatisable ifandonly iftheconstrained instance issatisable . INDEPENDENTSET!VERTEXCOVER Some reductions relyoningenuity torelate twovery different problems .Others simply record thefact that oneproblem isathin disguise ofanother .Toreduce INDEPENDENTSETto VERTEXCOVERwejust need tonotice that asetofnodesSisavertex cover ofgraphG= (V;E)(that is,Stouchesevery edge inE)ifand only iftheremaining nodes ,VS,arean independent setofG(Figure 8.9). Therefore ,tosolve aninstance (G;g)ofINDEPENDENTSET,simply look foravertex cover ofGwithjVjgnodes .Ifsuchavertex cover exists ,then take allnodes notinit.Ifnosuch vertex cover exists ,thenGcannot possibly haveanindependent setofsizeg. INDEPENDENTSET!CLIQUE INDEPENDENTSETand CLIQUEarealsoeasy toreduce tooneanother .Dene thecomplement ofagraphG=(V;E)tobeG=(V;E),whereEcontains precisely those unordered pairs of vertices that arenotinE.Then asetofnodesSisanindependent setofGifandonly ifSis aclique ofG.Toparaphrase ,these nodes havenoedges between them inGifandonly ifthey haveallpossible edges between them inG. Therefore ,wecanreduce INDEPENDENTSETtoCLIQUEbymapping aninstance (G;g)
8âŒ˜20âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 267 ofINDEPENDENTSETtothecorresponding instance (G;g)ofCLIQUE;thesolution toboth is identical. 3SAT!3DMATCHING Again, twovery different problems .Wemust reduce 3SATtotheproblem ofnding ,among asetofboy-girl-pet triples ,asubset that contains eachboy,eachgirl, and eachpetexactly once.Inshort, wemust design sets ofboy-girl-pet triples that somehow beha velikeBoolean variables andgates! Consider thefollowing setoffour triples ,eachrepresented byatriangular node joining a boy,girl, andpet: p1 p3g0 g1 b1b0 p0 p2 Suppose that thetwoboysb0andb1andthetwogirlsg0andg1arenotinvolved inanyother triples .(The four petsp0;:::;p3willofcourse belong toother triples aswell; forotherwise the instance would trivially havenosolution.) Then anymatc hing must contain either thetwo triples (b0;g1;p0);(b1;g0;p2)orthetwotriples (b0;g0;p1);(b1;g1;p3),because these aretheonly waysinwhic hthese twoboys andgirls cannd anymatc h.Therefore ,thisÂ“gadgetÂ” hastwo possible states: itbeha veslikeaBoolean variable! Tothen transform aninstance of3SATtooneof3DMATCHING,westart bycreating acopy ofthepreceding gadget foreachvariablex.Call theresulting nodespx1;bx0;gx1,and soon. Theintended interpretation isthat boybx0ismatc hedwith girlgx1ifx=true ,andwith girl gx0ifx=false . Next wemust create triples that somehow mimic clauses .Foreachclause ,sayc=(x_y_z), introduce anew boybcandanew girlgc.They willbeinvolved inthree triples ,oneforeach literal intheclause .And thepets inthese triples must reect thethree wayswhereby the clause canbesatised: (1)x=true ,(2)y=false ,(3)z=true .For(1),wehavethetriple (bc;gc;px1),wherepx1isthepetp1inthegadget forx.Here iswhy wechosep1:ifx=true , thenbx0ismatc hedwithgx1andbx1withgx0,andsopetspx0andpx2aretaken. Inwhic hcase bcandgccanbematc hedwithpx1.Butifx=false ,thenpx1andpx3aretaken, andsogcand bccannot beaccommodated this way.Wedothesame thing fortheother twoliterals ofthe
8âŒ˜21âŒ˜268 Algorithms clause ,whic hyield triples involvingbcandgcwith eitherpy0orpy2(forthenegated variable y)andwith eitherpz1orpz3(forvariablez). Wehavetomake sure that forevery occurrence ofaliteral inaclausecthere isadifferent pettomatc hwithbcandgc.Butthis iseasy: byanearlier reduction wecanassume that no literal appears more than twice ,andsoeachvariable gadget hasenough pets,twofornegated occurrences andtwoforunnegated. The reduction now seems complete: from anymatc hing wecanrecover asatisfying truth assignment bysimply looking ateachvariable gadget and seeing with whic hgirlbx0was matc hed. And from anysatisfying truth assignment wecanmatc hthegadget corresponding toeachvariablexsothat triples (bx0;gx1;px0)and(bx1;gx0;px2)arechosen ifx=true and triples (bx0;gx0;px1)and(bx1;gx1;px3)arechosen ifx=false ;andforeachclausecmatc hbc andgcwith thepetthat corresponds tooneofitssatisfying literals . Butonelastproblem remains: inthematc hing dened attheendofthelastparagraph, some pets may beleftunmatc hed.Infact, ifthere arenvariables andmclauses ,then exactly 2nmpets will beleftunmatc hed(you cancheckthat this number issure tobepositive , because wehaveatmost three occurrences ofevery variable ,andatleast twoliterals inevery clause). But this iseasy tox:Add2nmnew boy-girl couples that areÂ“generic animal- lovers ,Â”andmatc hthem bytriples with allthepets! 3DMATCHING!ZOE Recall that inZOEwearegiven anmnmatrix Awith01entries ,andwemust nda01 vector x=(x1;:::;xn)suchthat themequations Ax=1 aresatised, where by1wedenote thecolumn vector ofall1's.How canweexpress the3D MATCHINGproblem inthisframework? ZOEand ILParevery useful problems precisely because they provide aformat inwhic h many combinatorial problems canbeexpressed. Insuchaformulation wethink ofthe01 variables asdescribing asolution, and wewrite equations expressing theconstraints ofthe problem. Forexample ,here ishow weexpress aninstance of3DMATCHING(mboys,mgirls,m pets,andnboy-girl-pet triples) inthelanguage ofZOE.Wehave01variablesx1;:::;xn, onepertriple ,wherexi=1means that theithtriple ischosen forthematc hing,andxi=0 means that itisnotchosen. Now allwehavetodoiswrite equations stating that thesolution described bythexi'sis alegitimate matc hing.Foreachboy(orgirl, orpet), suppose that thetriples containing him (orher,orit)arethose numbered j1;j2;:::;jk;theappropriate equation isthen xj1+xj2++xjk=1; whic hstates that exactly oneofthese triples must beincluded inthematc hing.Forexample , here istheAmatrix foraninstance of3DMATCHINGwesawearlier .
8âŒ˜22âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 269 Armadillo BobcatCarolBeatriceAlice Chet Bob Al CanaryA=0 BBBBBBBBBBBB@10000 00011 01100 10001 01000 00110 10001 00110 010001 CCCCCCCCCCCCA Thevecolumns ofAcorrespond tothevetriples ,while thenine rows areforAl,Bob,Chet, Alice ,Beatrice ,Carol, Armadillo ,Bobcat, andCanary ,respectively . Itisstraightforw ardtoargue that solutions tothetwoinstances translate backandforth. ZOE!SUBSETSUM This isareduction between twospecial cases ofILP:onewith many equations butonly0 1coefcients ,and theother with asingle equation butarbitrary integer coefcients .The reduction isbased onasimple andtime-honored idea: 01vectors canencode numbers! Forexample ,given thisinstance ofZOE: A=0 BBBB@1000 0001 0110 1000 01001 CCCCA; wearelooking forasetofcolumns ofAthat, added together ,make uptheall-1'svector .But ifwethink ofthecolumns asbinary integers (read from toptobottom), wearelooking fora subset oftheintegers 18;5;4;8that adduptothebinary integer 11111 2=31.And this isan instance ofSUBSETSUM.Thereduction iscomplete! Except foronedetail, theonethat usually spoils theclose connection between 01vec- tors andbinary integers: carry .Because ofcarry ,5-bitbinary integers canaddupto31(for example ,5+6+20=31or,inbinary ,00101 2+00110 2+10100 2=11111 2)even when thesum ofthecorresponding vectors isnot(1;1;1;1;1).Butthis iseasy tox:Think ofthecolumn vectors notasintegers inbase2,butasintegers inbasen+1Â—one more than thenumber of columns .This way,since atmostnintegers areadded, andalltheir digits are0and1,there canbenocarry ,andourreduction works . ZOE!ILP 3SATisaspecial case ofSATÂ—or,SATisageneralization of3SAT.Byspecial case wemean that theinstances of3SATareasubset oftheinstances ofSAT(inparticular ,theones with nolong clauses), andthedenition ofsolution isthesame inboth problems (anassignment
8âŒ˜23âŒ˜270 Algorithms Figure 8.10 Rudrata cyclewith paired edges:C=f(e1;e3);(e5;e6);(e4;e5);(e3;e7);(e3;e8)g. e7e1 e5 e4e8e3e2 e6 satisfying allclauses). Consequently ,there isareduction from 3SATtoSAT,inwhic htheinput undergoes notransformation, andthesolution tothetarget instance isalso kept unchanged. Inother words ,functionsfandhfrom thereduction diagram (onpage 259) areboth the identity . This sounds trivial enough, butitisavery useful and common wayofestablishing that aproblem isNP-complete: Simply notice that itisageneralization ofaknown NP-complete problem. Forexample ,the SETCOVERproblem isNP-complete because itisageneraliza- tion ofVERTEXCOVER(and also,incidentally ,of3DMATCHING).SeeExercise 8.10 formore examples . Often ittakes alittle work toestablish that oneproblem isaspecial case ofanother .The reduction from ZOEtoILPisacase inpoint. InILPwearelooking foraninteger vector x that satises Axb,forgiven matrix Aandvector b.Towrite aninstance ofZOEinthis precise form, weneed torewrite eachequation ofthe ZOEinstance astwoinequalities (recall thetransformations ofSection 7.1.4), andtoaddforeachvariablexitheinequalities xi1 andxi0. ZOE!RUDRATACYCLE IntheRUDRATACYCLEproblem weseek acycleinagraph that visits every vertex exactly once.Weshall prove itNP-complete intwostages: rst wewillreduce ZOEtoageneralization ofRUDRATACYCLE,called RUDRATACYCLEWITHPAIREDEDGES,andthen weshall seehow togetridoftheextra features ofthat problem and reduce ittotheplain RUDRATACYCLE problem. Inaninstance ofRUDRATACYCLEWITHPAIREDEDGESwearegiven agraphG=(V;E) and asetCEEofpairs ofedges .Weseek acyclethat (1)visits allvertices once,like aRudrata cycleshould, and(2)forevery pair ofedges (e;e0)inC,traverses either edgeeor edgee0Â—exactl yoneofthem. Inthesimple example ofFigure 8.10 asolution isshown inbold. Notice that weallow twoormore parallel edges between twonodesÂ—a feature that doesn't
8âŒ˜24âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 271 Figure 8.11 Reducing ZOEtoRUDRATACYCLEWITHPAIREDEDGES. variables equations make sense inmost graph problemsÂ—since now thedifferent copies ofanedge canbepaired with other copies ofedges inwaysthat domake adifference . Now forthereduction ofZOEtoRUDRATACYCLEWITHPAIREDEDGES.Given aninstance ofZOE,Ax=1(where Aisanmnmatrix with01entries ,andthus describesmequations innvariables), thegraph weconstruct hasthevery simple structure shown inFigure 8.11: a cyclethat connectsm+ncollections ofparallel edges .Foreachvariablexiwehavetwoparallel edges (corresponding toxi=1andxi=0).And foreachequationxj1++xjk=1involving kvariables wehavekparallel edges ,oneforevery variable appearing intheequation. This isthewhole graph. Evidently ,any Rudrata cycleinthis graph must traverse them+n collections ofparallel edges onebyone,choosing oneedge from eachcollection. This way,the cycleÂ“choosesÂ” foreachvariable avalueÂ— 0or1Â—and, foreachequation, avariable appearing init. The whole reduction can't bethis simple ,ofcourse .The structure ofthematrix A(and notjustitsdimensions) must bereected somewhere ,andthere isoneplace left: thesetCof pairs ofedges suchthat exactly oneedge ineachpair istraversed. Forevery equation (recall there aremintotal), and forevery variablexiappearing init,weaddtoCthepair(e;e0) whereeistheedge corresponding totheappearance ofxiinthat particular equation (onthe left-hand side ofFigure 8.11), ande0istheedge corresponding tothevariable assignment xi=0(ontheright side ofthegure). This completes theconstruction. Takeanysolution ofthisinstance ofRUDRATACYCLEWITHPAIREDEDGES.Asdiscussed before ,itpicksavalue foreachvariable andavariable forevery equation. Weclaim that the values thus chosen areasolution totheoriginal instance ofZOE.Ifavariablexihasvalue 1, then theedgexi=0isnottraversed, andthus alledges associated withxiontheequation
8âŒ˜25âŒ˜272 Algorithms side must betraversed (since they arepaired inCwith thexi=0edge). So,ineachequation exactly oneofthevariables appearing inithasvalue 1Â—whic histhesame assaying that all equations aresatised. Theother direction isstraightforw ardaswell: from asolution tothe instance ofZOEoneeasily obtains anappropriate Rudrata cycle. Getting Rid oftheEdge Pairs. Sofarwehaveareduction from ZOEtoRUDRATACYCLE WITHPAIREDEDGES;butwearereally interested inRUDRATACYCLE,whic hisaspecial case oftheproblem with paired edges: theoneinwhic hthesetofpairsCisempty .Toaccomplish ourgoal, weneed, asusual, tondawayofgetting ridoftheunwanted featureÂ—in thiscase theedge pairs . Consider thegraph shown inFigure 8.12, andsuppose that itisapart ofalarger graph Ginsuchawaythat only thefour endpoints a;b;c;dtouchtherest ofthegraph. Weclaim that thisgraph hasthefollowing important property: inanyRudrata cycle ofGthesubgraph shown must betraver sedinoneofthetwoways shown inbold inFigure 8.12(b) and(c).Here iswhy.Suppose that thecyclerst enters thesubgraph from vertexacontinuing tof.Then itmust continue tovertexg,becauseghasdegree 2and soitmust bevisited immediately after oneofitsadjacent nodes isvisitedÂ—otherwise there isnowaytoinclude itinthecycle. Hence wemust goontonodeh,andhere weseem tohaveachoice .Wecould continue onto j,orreturn toc.Butifwetake thesecond option, how arewegoing tovisit therest ofthe subgraph? (ARudrata cyclemust leavenovertex unvisited.) Itiseasy toseethat thiswould beimpossible ,andsofromhwehavenochoice buttocontinue tojandfrom there tovisit the rest ofthegraph asshown inFigure 8.12(b). Bysymmetry ,iftheRudrata cycleenters this subgraph atc,itmust traverse itasinFigure 8.12(c). And these aretheonly twoways. Butthis property tells ussomething important: this gadget beha vesjust liketwoedges fa;bgandfc;dgthat arepaired upintheRUDRATACYCLEWITHPAIREDEDGESproblem (see Figure 8.12(d)). Therestofthereduction isnow clear: toreduce RUDRATACYCLEWITHPAIREDEDGESto RUDRATACYCLEwegothrough thepairs inConebyone.Togetridofeachpair(fa;bg;fc;dg) wereplace thetwoedges with thegadget inFigure 8.12(a). Forany other pair inCthat involvesfa;bg,wereplace theedgefa;bgwith thenew edgefa;fg,wherefisfrom thegadget: thetraversal offa;fgisfrom now onanindication that edgefa;bgintheoldgraph would betraversed. Similarly ,fc;hgreplacesfc;dg.AfterjCjsuchreplacements (performed in polynomial time,since eachreplacement adds only 12vertices tothegraph) wearedone , andtheRudrata cyclesintheresulting graph willbeinone-to-one correspondence with the Rudrata cyclesintheoriginal graph that conform totheconstraints inC.
8âŒ˜26âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 273 Figure 8.12 Agadget forenforcing paired beha vior. (a) a cf m s b d q p j hgl k n r (b) a cb d (c) a cb d (d) a cb dC=f(fa;bg;fc;dg)g
8âŒ˜27âŒ˜274 Algorithms RUDRATACYCLE!TSP Given agraphG=(V;E),construct thefollowing instance ofthe TSP:thesetofcities isthe same asV,and thedistance between citiesuandvis1iffu;vgisanedge ofGand1+ otherwise ,forsome >1tobedetermined. The budget ofthe TSPinstance isequal tothe number ofnodes ,jVj. Itiseasy toseethat ifGhasaRudrata cycle,then thesame cycleisalso atour within the budget ofthe TSPinstance; andthat conversely ,ifGhasnoRudrata cycle,then there isno solution: thecheapest possible TSPtour hascost atleastn+ (itmust useatleast oneedge oflength 1+ ,andthetotal length ofalln1others isatleastn1).Thus RUDRATACYCLE reduces toTSP. Inthisreduction, weintroduced theparameter because byvarying it,wecanobtain two interesting results .If =1,then alldistances areeither 1or2,andsothis instance ofthe TSPsatises thetriangle inequality: ifi;j;karecities ,thendij+djkdik(proof:a+bc holds foranynumbers 1a;b;c2).This isaspecial case ofthe TSPwhic hisofpractical importance and whic h,asweshall seeinChapter 9,isinacertain sense easier ,because it canbeefciently approximated . Ifontheother hand islarge ,then theresulting instance ofthe TSPmaynotsatisfy the triangle inequality ,buthasanother important property: either ithasasolution ofcostnor less,orallitssolutions havecost atleastn+ (whic hnow canbearbitrarily larger thann). There canbenothing inbetween! Asweshall seeinChapter 9,this important gapproperty implies that, unless P=NP,noapproximation algorithm ispossible . ANYPROBLEMINNP!SAT Wehavereduced SATtothevarious searc hproblems inFigure 8.7. Now wecome fullcircle andargue that allthese problemsÂ—and infactallproblems inNPÂ—reduce toSAT. Inparticular ,weshall show that allproblems inNPcanbereduced toageneralization ofSATwhic hwecall CIRCUITSAT.InCIRCUITSATwearegiven a(Boolean) circuit (see Figure 8.13, andrecall Section 7.7), adagwhose vertices aregates ofvedifferent types: ANDgates and ORgates haveindegree 2. NOTgates haveindegree 1. Known input gates havenoincoming edges andarelabeledfalse ortrue . Unknown input gates havenoincoming edges andarelabeled Â“?Â”. One ofthesinks ofthedagisdesignated astheoutput gate. Given anassignment ofvalues totheunknown inputs ,wecanevaluate thegates ofthe circuit intopological order ,using therules ofBoolean logic (suchasfalse_true =true ), until weobtain thevalue attheoutput gate.This isthevalue ofthecircuit fortheparticular assignment totheinputs .Forinstance ,thecircuit inFigure8.13 evaluates tofalse under theassignment true;false;true (from lefttoright). CIRCUITSATisthen thefollowing searc hproblem: Given acircuit, ndatruth assignment fortheunknown inputs suchthat theoutput gate evaluates totrue ,orreport that nosuch
8âŒ˜28âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 275 Figure 8.13 Aninstance ofCIRCUITSAT. trueANDNOTAND OR OR ? ?output ?AND assignment exists .Forexample ,ifpresented with thecircuit inFigure 8.13 wecould have returned theassignment (false;true;true)because ,ifwesubstitute these values tothe unknown inputs (from lefttoright), theoutput becomestrue . CIRCUITSATisageneralization ofSAT.Toseewhy,notice that SATasks forasatisfying truth assignment foracircuit that hasthis simple structure: abunc hofANDgates atthe topjointheclauses ,andtheresult ofthisbig ANDistheoutput. Eachclause isthe ORofits literals .And eachliteral iseither anunknown input gate orthe NOTofone.There areno known input gates . Going intheother direction, CIRCUITSATcanalso bereduced toSAT.Here ishow wecan rewrite any circuit inconjunctive normal form (the ANDofclauses): foreachgateginthe circuit wecreate avariableg,andwemodel theeffect ofthegate using afewclauses: Gategg g gg AND NOT OR h1 h1 h2 h2 hfalse true (g) (g) (g_h2) (g_h1) (g_h1_h2)(g_h1) (g_h2)(g_h) (g_h) (g_h1_h2) (Doyouseethat these clauses do,infact, force exactly thedesired effect?) And tonish up, ifgistheoutput gate,weforce ittobetrue byadding theclause (g).Theresulting instance
8âŒ˜29âŒ˜276 Algorithms ofSATisequivalent tothegiven instance ofCIRCUITSAT:thesatisfying truth assignments of thisconjunctive normal form areinone-to-one correspondence with those ofthecircuit. Now that weknow CIRCUITSATreduces toSAT,weturn toourmain job,showing that all searc hproblems reduce toCIRCUITSAT.So,suppose thatAisaproblem inNP.Wemust discover areduction fromAtoCIRCUITSAT.This sounds very difcult, because weknow almost nothing aboutA! Allweknow aboutAisthat itisasearc hproblem, sowemust putthisknowledge towork. Themain feature ofasearc hproblem isthat anysolution toitcanquicklybechecked: there isanalgorithmCthat checks,given aninstanceIandaproposed solutionS,whether ornot Sisasolution ofI.Moreover ,Cmakes thisdecision intime polynomial inthelength ofI(we canassume thatSisitself encoded asabinary string ,and weknow that thelength ofthis string ispolynomial inthelength ofI). Recall now ourargument inSection 7.7that anypolynomial algorithm canberendered asacircuit, whose input gates encode theinput tothealgorithm. Naturally ,foranyinput length (number ofinput bits) thecircuit willbescaled totheappropriate number ofinputs , butthetotal number ofgates ofthecircuit willbepolynomial inthenumber ofinputs .Ifthe polynomial algorithm inquestion solves aproblem that requires ayesornoanswer (asisthe situation withC:Â“DoesSencode asolution totheinstance encoded byI?Â”),then thisanswer isgiven attheoutput gate. Weconclude that, given anyinstanceIofproblemA,wecanconstruct inpolynomial time acircuit whose known inputs arethebitsofI,andwhose unknown inputs arethebitsofS, suchthat theoutput istrue ifandonly iftheunknown inputs spell asolutionSofI.Inother words ,thesatisfying truth assignments totheunknown inputs ofthecircuit areinone-to-one correspondence with thesolutions ofinstanceIofA.Thereduction iscomplete .
8âŒ˜30âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 277 Unsolvable problems Atleast anNP-complete problem canbesolved bysome algorithmÂ—the trouble isthat this algorithm will beexponential. But itturns outthere areperfectly decent computational problems forwhic hnoalgorithms exist atall! One famous problem ofthis sort isanarithmetical version ofSAT.Given apolynomial equation inmany variables ,perhaps x3yz+2y4z27xy5z=6; arethere integer values ofx;y;zthat satisfy it?There isnoalgorithm that solves this problem. Noalgorithm atall,polynomial, exponential, doubly exponential, orworse! Such problems arecalled unsolvable . The rst unsolvable problem wasdiscovered in1936 byAlan M.Turing ,then astudent ofmathematics atCambridge ,England. ]When Turing came upwith it,there were no computers orprogramming languages (infact, itcanbeargued that these things came about later exactl ybecause thisbrilliant thought occurred toTuring). Buttodaywecanstate itin familiar terms . Suppose that youaregiven aprogram inyour favorite programming language ,along with aparticular input. Willtheprogram ever terminate ,once started onthis input? This isavery reasonable question. Many ofuswould beecstatic ifwehadanalgorithm, callit terminates(p,x) ,that took asinput alecontaining aprogramp,and aleofdatax, andafter grinding away,nally tolduswhether ornotpwould ever stop ifstarted onx. Buthow would yougoabout writing theprogramterminates ?(Ifyouhaven't seen this before ,it'sworth thinking about itforawhile ,toappreciate thedifculty ofwriting suchan Â“universal innite-loop detector .Â”) Well,youcan't. Suchanalgorithm does notexist! And here istheproof: Suppose weactually had suchaprogramterminates(p,x) . Then wecould useitasasubroutine ofthefollowing evilprogram: function paradox(z:file) 1:ifterminates(z,z )goto1 Notice whatparadox does: itterminates ifand only ifprogramzdoes notterminate when given itsown code asinput. Youshould smell trouble .What ifweputthisprogram inalenamedparadox andwe executedparadox(parado x)?Would this execution ever stop? Ornot? Neither answer is possible .Since wearrived atthis contradiction byassuming that there isanalgorithm for telling whether programs terminate ,wemust conclude that this problem cannot besolved byanyalgorithm. Bytheway,allthis tells ussomething important about programming: Itwillnever be automated, itwillforever depend ondiscipline ,ingenuity ,andhackery.Wenow know that youcan't tellwhether aprogram hasaninnite loop.But canyoutellifithasabuffer overrun? Doyouseehow tousetheunsolvability oftheÂ“halting problemÂ” toshow that this, too,isunsolvable?
8âŒ˜31âŒ˜278 Algorithms Exercises 8.1. Optimization versussearc h.Recall thetraveling salesman problem: TSP Input: Amatrix ofdistances; abudgetb Output: Atour whic hpasses through allthecities andhaslengthb,ifsuchatour exists . Theoptimization version ofthisproblem asks directly fortheshortest tour. TSP-OPT Input: Amatrix ofdistances Output: Theshortest tour whic hpasses through allthecities . Show that ifTSPcanbesolved inpolynomial time,then socan TSP-OPT. 8.2. Searc hversusdecision. Suppose youhaveaprocedure whic hruns inpolynomial time andtells youwhether ornotagraph hasaRudrata path. Show that youcanuseittodevelop apolynomial- time algorithm forRUDRATAPATH(whic hreturns theactual path, ifitexists). 8.3. STINGYSATisthefollowing problem: given asetofclauses (eachadisjunction ofliterals) and anintegerk,nd asatisfying assignment inwhic hatmostkvariables aretrue ,ifsuchan assignment exists .Prove that STINGYSATisNP-complete . 8.4. Consider the CLIQUEproblem restricted tographs inwhic hevery vertex hasdegree atmost 3. Call thisproblem CLIQUE-3. (a)Prove that CLIQUE-3isinNP. (b)What iswrong with thefollowing proof ofNP-completeness forCLIQUE-3? Weknow that the CLIQUEproblem ingeneral graphs isNP-complete ,soitisenough to present areduction from CLIQUE-3toCLIQUE.Given agraphGwith vertices ofdegree3, andaparameter g,thereduction leavesthegraph andtheparameter unchanged: clearly theoutput ofthereduction isapossible input forthe CLIQUEproblem. Furthermore ,the answer toboth problems isidentical. This proves thecorrectness ofthereduction and, therefore ,theNP-completeness ofCLIQUE-3. (c)Itistrue that the VERTEXCOVERproblem remains NP-complete even when restricted to graphs inwhic hevery vertex hasdegree atmost 3.Call thisproblem VC-3.What iswrong with thefollowing proof ofNP-completeness forCLIQUE-3? Wepresent areduction from VC-3toCLIQUE-3.Given agraphG=(V;E)with node degrees bounded by3,andaparameter b,wecreate aninstance ofCLIQUE-3byleaving thegraph unchanged andswitc hing theparameter tojVjb.Now,asubsetCVisavertex cover inGifandonly ifthecomplementary setVCisaclique inG.ThereforeGhasavertex cover ofsizebifandonly ifithasaclique ofsizejVjb.This proves thecorrectness of thereduction and, consequently ,theNP-completeness ofCLIQUE-3. (d)Describe anO(jVj4)algorithm forCLIQUE-3. 8.5. Give asimple reduction from 3DMATCHINGtoSAT,andanother from RUDRATACYCLEtoSAT. (Hint: Inthelatter case youmayusevariablesxijwhose intuitive meaning isÂ“vertexiisthe jthvertex oftheHamilton cycleÂ”;youthen need towrite clauses that express theconstraints of theproblem.)
8âŒ˜32âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 279 8.6. Onpage 266wesawthat 3SATremains NP-complete even when restricted toformulas inwhic h eachliteral appears atmost twice . (a)Show that ifeachliteral appears atmost once,then theproblem issolvable inpolynomial time. (b)Show that INDEPENDENTSETremains NP-complete even inthespecial case when allthe nodes inthegraph havedegree atmost 4. 8.7. Consider aspecial case of3SATinwhic hallclauses haveexactly three literals ,andeachvariable appears atmost three times .Show that this problem canbesolved inpolynomial time.(Hint: create abipartite graph with clauses ontheleft, variables ontheright, andedges whenever a variable appears inaclause .UseExercise 7.30 toshow that thisgraph hasamatc hing.) 8.8. Inthe EXACT4SATproblem, theinput isasetofclauses ,eachofwhic hisadisjunction ofexactly four literals ,andsuchthat eachvariable occurs atmost once ineachclause .Thegoal istond asatisfying assignment, ifoneexists .Prove that EXACT4SATisNP-complete . 8.9. Inthe HITTINGSETproblem, wearegiven afamily ofsetsfS1;S2;:::;Sngandabudgetb,and wewish tondasetHofsizebwhic hintersects everySi,ifsuchanHexists .Inother words , wewantH\Si6=;foralli. Show that HITTINGSETisNP-complete . 8.10. Proving NP-completeness bygeneralization. Foreachoftheproblems below ,prove that itisNP- complete byshowing that itisageneralization ofsome NP-complete problem wehaveseen in thischapter . (a)SUBGRAPHISOMORPHISM:Given asinput two undirected graphsGandH,determine whetherGisasubgraph ofH(that is,whether bydeleting certain vertices andedges ofH weobtain agraph that is,uptorenaming ofvertices ,identical toG),andifso,return the corresponding mapping ofV(G)intoV(H). (b)LONGESTPATH:Given agraphGandanintegerg,ndinGasimple path oflengthg. (c)MAXSAT:Given aCNF formula andanintegerg,ndatruth assignment that satises at leastgclauses . (d)DENSESUBGRAPH:Given agraph and twointegersaandb,nd asetofavertices ofG suchthat there areatleastbedges between them. (e)SPARSESUBGRAPH:Given agraph and twointegersaandb,nd asetofavertices ofG suchthat there areatmostbedges between them. (f)SETCOVER.(This problem generalizes twoknown NP-complete problems .) (g)RELIABLENETWORK:Wearegiven twonnmatrices ,adistance matrixdijandaconnec- tivity requirement matrixrij,aswell asabudgetb;wemust ndagraphG=(f1;2;:::;ng;E) suchthat (1)thetotal costofalledges isborlessand(2)between anytwodistinct vertices iandjthere arerijvertex-disjoint paths .(Hint: Suppose that alldij'sare1or2,b=n,and allrij'sare2.Whic hwell known NP-complete problem isthis?) 8.11. There aremany variants ofRudrata' sproblem, depending onwhether thegraph isundirected or directed, andwhether acycleorpath issought. Reduce the DIRECTEDRUDRATAPATHproblem toeachofthefollowing . (a)The(undirected) RUDRATAPATHproblem.
8âŒ˜33âŒ˜280 Algorithms (b)The undirected RUDRATA(s;t)-PATHproblem, whic hisjust like RUDRATAPATHexcept that theendpoints ofthepath arespecied intheinput. 8.12. Thek-SPANNINGTREEproblem isthefollowing . Input: Anundirected graphG=(V;E) Output: Aspanning tree ofGinwhic heachnode hasdegreek,ifsuchatree exists . Show that foranyk2: (a)k-SPANNINGTREEisasearc hproblem. (b)k-SPANNINGTREEisNP-complete .(Hint: Start withk=2and consider therelation between thisproblem andRUDRATAPATH.) 8.13. Determine whic hofthefollowing problems areNP-complete andwhic haresolvable inpolyno- mial time.Ineachproblem youaregiven anundirected graphG=(V;E),along with: (a)AsetofnodesLV,andyoumust ndaspanning tree suchthat itssetofleavesincludes thesetL. (b)AsetofnodesLV,and youmust nd aspanning tree suchthat itssetofleavesis precisely thesetL. (c)AsetofnodesLV,and youmust nd aspanning tree suchthat itssetofleavesis included inthesetL. (d)Anintegerk,andyoumust ndaspanning tree withkorfewer leaves. (e)Anintegerk,andyoumust ndaspanning tree withkormore leaves. (f)Anintegerk,andyoumust ndaspanning tree with exactlykleaves. (Hint: AlltheNP-completeness proofs arebygeneralization, except forone.) 8.14. Prove that thefollowing problem isNP-complete: given anundirected graphG=(V;E)andan integerk,return aclique ofsizekaswell asanindependent setofsizek,provided both exist. 8.15. Show that thefollowing problem isNP-complete . MAXIMUMCOMMONSUBGRAPH Input: Two graphsG1=(V1;E1)andG2=(V2;E2);abudgetb. Output: Two setofnodesV0 1V1andV0 2V2whose deletion leavesatleastbnodes ineachgraph, andmakes thetwographs identical. 8.16. Wearefeeling experimental andwanttocreate anew dish. There arevarious ingredients we canchoose from and we'dlike touseasmany ofthem aspossible ,butsome ingredients don't gowell with others .Ifthere arenpossible ingredients (numbered 1ton),wewrite down an nnmatrix giving thediscord between anypair ofingredients .This discord isareal number between 0:0and1:0,where 0:0means Â“they gotogether perfectlyÂ” and1:0means Â“they really don't gotogether .Â”Here' sanexample matrix when there arevepossible ingredients . 1 2 3 4 5 10.0 0.4 0.2 0.9 1.0 20.4 0.0 0.1 1.0 0.2 30.2 0.1 0.0 0.8 0.5 40.9 1.0 0.8 0.0 0.2 51.0 0.2 0.5 0.2 0.0
8âŒ˜34âŒ˜S.Dasgupta, C.H.Papadimitriou, andU.V.Vazirani 281 Inthiscase,ingredients 2and3gotogether pretty well whereas 1and5clash badly .Notice that this matrix isnecessarily symmetric; and that thediagonal entries arealways0:0.Any setof ingredients incurs apenalty whic histhesum ofalldiscord values between pairsofingredients . Forinstance ,thesetofingredientsf1;3;5gincurs apenalty of0:2+1:0+0:5=1:7.Wewantthis penalty tobesmall. EXPERIMENTALCUISINE Input:n,thenumber ofingredients tochoose from;D,thennÂ“discordÂ” matrix; some numberp0 Output: Themaximum number ofingredients wecanchoose with penaltyp. Show that ifEXPERIMENTALCUISINEissolvable inpolynomial time,then sois3SAT. 8.17. Show that foranyproblem inNP,there isanalgorithm whic hsolves intimeO(2p(n)),where nisthesizeoftheinput instance andp(n)isapolynomial (whic hmaydepend on). 8.18. Show that ifP=NPthen theRSA cryptosystem (Section 1.4.2) canbebroken inpolynomial time. 8.19. Akiteisagraph onaneven number ofvertices ,say2n,inwhic hnofthevertices form aclique andtheremaining nvertices areconnected inaÂ“tailÂ” that consists ofapath joined tooneofthe vertices oftheclique .Given agraph andagoalg,the KITEproblem asks forasubgraph whic h isakiteandwhic hcontains 2gnodes .Prove that KITEisNP-complete . 8.20. Inanundirected graphG=(V;E),wesayDVisadominating setifeveryv2Viseither inDoradjacent toatleast onemember ofD.Inthe DOMINATINGSETproblem, theinput isa graph andabudgetb,andtheaim istond adominating setinthegraph ofsizeatmostb,if oneexists .Prove that thisproblem isNP-complete . 8.21. Sequencing byhybridization. One experimental procedure foridentifying anew DNA sequence repeatedly probes ittodetermine whic hk-mers (substrings oflengthk)itcontains .Based on these ,thefullsequence must then bereconstructed. Let'snow formulate this asacombinatorial problem. Forany stringx(the DNA sequence), let(x)denote themultiset ofallofitsk-mers .Inparticular ,(x)contains exactlyjxjk+1 elements . The reconstruction problem isnow easy tostate: given amultiset ofk-length strings ,nd a stringxsuchthat(x)isexactly thismultiset. (a)Show that thereconstruction problem reduces toRUDRATAPATH.(Hint: Construct adi- rected graph with onenode foreachk-mer,and with anedge fromatobifthelastk1 characters ofamatc htherstk1characters ofb.) (b)Butinfact, there ismuchbetter news .Show that thesame problem also reduces toEULER PATH.(Hint: This time,useonedirected edge foreachk-mer.) 8.22. Intask scheduling ,itiscommon touseagraph representation with anode foreachtask anda directed edge from taskitotaskjifiisaprecondition forj.This directed graph depicts the precedence constraints inthescheduling problem. Clearly ,aschedule ispossible ifandonly if thegraph isacyclic;ifitisn't, we'dliketoidentify thesmallest number ofconstraints that must bedropped soastomake itacyclic. Given adirected graphG=(V;E),asubsetE0Eiscalled afeedbac karcsetiftheremoval of edgesE0rendersGacyclic.
8âŒ˜35âŒ˜282 Algorithms FEEDBACKARCSET(FAS):Given adirected graphG=(V;E)andabudgetb,nd a feedbac karcsetofbedges ,ifoneexists . (a)Show that FASisinNP. FAScanbeshown tobeNP-complete byareduction from VERTEXCOVER.Given aninstance (G;b)ofVERTEXCOVER,whereGisanundirected graph andwewantavertex cover ofsizeb, weconstruct ainstance (G0;b)ofFASasfollows .IfG=(V;E)hasnverticesv1;:::;vn,then make G0=(V0;E0)adirected graph with2nverticesw1;w0 1;:::;wn;w0 n,andn+2jEj(directed) edges: (wi;w0 i)foralli=1;2;:::;n. (w0 i;wj)and(w0 j;wi)forevery (vi;vj)2E. (b)Show that ifGcontains avertex cover ofsizeb,thenG0contains afeedbac karcsetofsize b. (c)Show that ifG0contains afeedbac karcsetofsizeb,thenGcontains avertex cover ofsize (atmost)b.(Hint: given afeedbac karcsetofsizebinG0,youmayneed torst modify it slightly toobtain another onewhic hisofamore convenient form, butisofthesame sizeor smaller .Then, argue thatGmust contain avertex cover ofthesame size asthemodied feedbac karcset.) 8.23. Inthe NODE-DISJOINTPATHSproblem, theinput isanundirected graph inwhic hsome vertices havebeen specially marked: acertain number ofÂ“sourcesÂ”s1;s2;:::skandanequal number of Â“destinationsÂ” t1;t2;:::tk.Thegoal istondknode-disjoint paths (that is,paths whic hhaveno nodes incommon) where theithpath goes fromsitoti.Show that thisproblem isNP-complete . Here isasequence ofprogressively stronger hints . (a)Reduce from 3SAT. (b)Fora3SATformula withmclauses andnvariables ,usek=m+nsources anddestinations . Introduce onesource/destination pair(sx;tx)foreachvariablex,andonesource/destination pair(sc;tc)foreachclausec. (c)Foreach3SATclause ,introduce 6new intermediate vertices ,oneforeachliteral occurring inthat clause andoneforitscomplement. (d)Notice that ifthepath fromsctotcgoes through some intermediate vertex representing , say,anoccurrence ofvariablex,then noother path cangothrough that vertex. What vertex would youliketheother path tobeforced togothrough instead?
